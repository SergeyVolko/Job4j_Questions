# Lambda. Stream API
## 1. Что такое lambda-выражение?
Lambda-выражение в Java — это способ создания анонимных функций, который позволяет писать более лаконичный и выразительный код, особенно в контексте функционального программирования. Lambda-выражения были введены в Java 8 и позволяют передавать поведение (например, методы) в качестве параметров.

### Основные характеристики lambda-выражений:

1. **Синтаксис**:
   Lambda-выражение состоит из трех основных частей:
   - Параметры (в круглых скобках)
   - Стрелка (`->`)
   - Тело (выражение или блок кода)

   Пример:
   ```java
   (int x, int y) -> x + y
   ```

2. **Типы**:
   Lambda-выражения могут быть использованы для реализации функциональных интерфейсов, то есть интерфейсов, которые содержат только один абстрактный метод. Примеры таких интерфейсов включают `Runnable`, `Callable`, `Comparator`, `Consumer`, `Function` и др.

3. **Упрощение кода**:
   Lambda-выражения позволяют избежать создания анонимных классов, что делает код более компактным и читаемым. 

4. **Применение**:
   Они часто используются в сочетании с новыми функциональными возможностями Java, такими как Stream API, для обработки коллекций.

### Пример использования:

1. **Простой пример**:
   ```java
   // Использование lambda-выражения для реализации интерфейса Runnable
   Runnable runnable = () -> System.out.println("Hello, World!");
   new Thread(runnable).start();
   ```

2. **Использование с коллекциями**:
   ```java
   List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

   // Использование lambda-выражения с методом forEach
   names.forEach(name -> System.out.println(name));
   ```

3. **Использование с Comparator**:
   ```java
   List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

   // Сортировка списка с использованием lambda-выражения
   Collections.sort(names, (a, b) -> a.length() - b.length());
   ```

### Заключение

Lambda-выражения делают код более лаконичным и выразительным, позволяя разработчикам легко передавать функциональность в качестве параметров, что особенно полезно при работе с коллекциями и потоками данных.

## 2. Что такое функциональные интерфейсы?
Функциональные интерфейсы в Java — это интерфейсы, которые содержат только один абстрактный метод. Они могут иметь любое количество статических методов и методов по умолчанию, но только один абстрактный метод. Функциональные интерфейсы являются основой для использования lambda-выражений и функционального программирования в Java.

### Основные характеристики функциональных интерфейсов:

1. **Ограничение на абстрактные методы**:
   - Функциональный интерфейс может содержать только один абстрактный метод. Это позволяет использовать его в качестве целевого типа для lambda-выражений или ссылок на методы.

2. **Аннотация `@FunctionalInterface`**:
   - Хотя аннотация `@FunctionalInterface` не является обязательной, ее использование рекомендуется. Она помогает компилятору проверять, что интерфейс действительно является функциональным, и предотвращает добавление дополнительных абстрактных методов.
   - Пример:
     ```java
     @FunctionalInterface
     public interface MyFunctionalInterface {
         void myMethod(); // единственный абстрактный метод
     }
     ```

3. **Использование с lambda-выражениями**:
   - Функциональные интерфейсы позволяют использовать lambda-выражения для создания экземпляров интерфейсов без необходимости писать анонимные классы.
   - Пример:
     ```java
     MyFunctionalInterface func = () -> System.out.println("Hello from functional interface!");
     func.myMethod(); // вызов метода
     ```

4. **Примеры стандартных функциональных интерфейсов**:
   - Java предоставляет несколько встроенных функциональных интерфейсов в пакете `java.util.function`, таких как:
     - `Runnable`: интерфейс без параметров, не возвращающий значение.
     - `Consumer<T>`: принимает один аргумент типа T и не возвращает значение.
     - `Function<T, R>`: принимает один аргумент типа T и возвращает значение типа R.
     - `Predicate<T>`: принимает один аргумент типа T и возвращает `boolean`.
     - `Supplier<T>`: не принимает аргументов и возвращает значение типа T.

### Пример функционального интерфейса:

```java
@FunctionalInterface
public interface MyCalculator {
    int calculate(int a, int b); // единственный абстрактный метод
}

// Использование с lambda-выражением
MyCalculator add = (a, b) -> a + b;
MyCalculator subtract = (a, b) -> a - b;

System.out.println(add.calculate(5, 3)); // вывод: 8
System.out.println(subtract.calculate(5, 3)); // вывод: 2
```

### Заключение

Функциональные интерфейсы играют ключевую роль в функциональном программировании на Java, обеспечивая целевые типы для lambda-выражений и упрощая работу с функциональными стилями обработки данных.

##  3. Перечислите функциональные интерфейсы из пакета java.util.function.
В пакете `java.util.function` Java предоставляет множество встроенных функциональных интерфейсов, которые можно использовать для различных целей в функциональном программировании. Вот основные из них:

1. **`Predicate<T>`**:
   - Принимает один аргумент типа T и возвращает `boolean`.
   - Используется для проверки условий.
   - Пример:
     ```java
     Predicate<Integer> isEven = x -> x % 2 == 0;
     ```

2. **`Consumer<T>`**:
   - Принимает один аргумент типа T и не возвращает значения.
   - Используется для выполнения операций с переданными данными.
   - Пример:
     ```java
     Consumer<String> print = s -> System.out.println(s);
     ```

3. **`Function<T, R>`**:
   - Принимает один аргумент типа T и возвращает значение типа R.
   - Используется для преобразования данных.
   - Пример:
     ```java
     Function<String, Integer> stringLength = s -> s.length();
     ```

4. **`Supplier<T>`**:
   - Не принимает аргументов и возвращает значение типа T.
   - Используется для предоставления данных.
   - Пример:
     ```java
     Supplier<Double> randomValue = () -> Math.random();
     ```

5. **`UnaryOperator<T>`**:
   - Принимает один аргумент типа T и возвращает значение того же типа T.
   - Это специализированный интерфейс для `Function`, где входной и выходной типы совпадают.
   - Пример:
     ```java
     UnaryOperator<Integer> square = x -> x * x;
     ```

6. **`BinaryOperator<T>`**:
   - Принимает два аргумента типа T и возвращает значение того же типа T.
   - Это специализированный интерфейс для `BiFunction`, где входные и выходные типы совпадают.
   - Пример:
     ```java
     BinaryOperator<Integer> add = (a, b) -> a + b;
     ```

7. **`BiPredicate<T, U>`**:
   - Принимает два аргумента типов T и U и возвращает `boolean`.
   - Используется для проверки условий с двумя аргументами.
   - Пример:
     ```java
     BiPredicate<String, Integer> isLengthEqual = (s, len) -> s.length() == len;
     ```

8. **`BiConsumer<T, U>`**:
   - Принимает два аргумента типов T и U и не возвращает значения.
   - Используется для выполнения операций с двумя аргументами.
   - Пример:
     ```java
     BiConsumer<String, Integer> printWithLength = (s, len) -> System.out.println(s + " has length " + len);
     ```

9. **`BiFunction<T, U, R>`**:
   - Принимает два аргумента типов T и U и возвращает значение типа R.
   - Используется для преобразования данных с двумя аргументами.
   - Пример:
     ```java
     BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;
     ```

### Заключение

Эти функциональные интерфейсы из пакета `java.util.function` обеспечивают мощные инструменты для работы с функциональным программированием в Java, позволяя разработчикам легко передавать функциональность и обрабатывать данные.

## 4. Что такое функции высшего порядка?
Функции высшего порядка (Higher-Order Functions, HOF) — это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. В Java, благодаря поддержке функционального программирования, особенно с введением лямбда-выражений и функциональных интерфейсов в Java 8, стало возможно использовать функции высшего порядка.

### Основные характеристики функций высшего порядка:

1. **Принимают функции как аргументы**:
   - Функция может принимать другую функцию в качестве параметра. Это позволяет передавать поведение в качестве аргумента.

2. **Возвращают функции**:
   - Функция может возвращать другую функцию. Это позволяет создавать функции, которые генерируют другие функции в зависимости от заданных параметров.

3. **Композиция функций**:
   - Функции высшего порядка могут использоваться для создания новых функций путем комбинирования других функций.

### Примеры функций высшего порядка в Java:

1. **Передача функции как аргумента**:
   ```java
   import java.util.function.Function;

   public class HigherOrderFunctionExample {
       public static void main(String[] args) {
           // Пример функции высшего порядка
           int result = applyFunction(5, x -> x * x); // передаем лямбда-выражение
           System.out.println("Результат: " + result); // вывод: Результат: 25
       }

       // Функция высшего порядка, принимающая другую функцию
       public static int applyFunction(int value, Function<Integer, Integer> func) {
           return func.apply(value); // применяем переданную функцию
       }
   }
   ```

2. **Возвращение функции**:
   ```java
   import java.util.function.Function;

   public class HigherOrderFunctionReturnExample {
       public static void main(String[] args) {
           Function<Integer, Function<Integer, Integer>> adder = createAdder(5);
           System.out.println(adder.apply(3)); // вывод: 8
       }

       // Функция высшего порядка, возвращающая другую функцию
       public static Function<Integer, Function<Integer, Integer>> createAdder(int x) {
           return (y) -> (z) -> x + y + z; // возвращаем функцию сложения
       }
   }
   ```

### Преимущества функций высшего порядка:

- **Упрощение кода**: Позволяют писать более компактный и читаемый код, избегая дублирования.
- **Гибкость**: Предоставляют возможность изменять поведение функций без изменения их реализации.
- **Композиция**: Облегчают создание сложных функций путем комбинирования простых.

### Заключение

Функции высшего порядка являются мощным инструментом в функциональном программировании, позволяя разработчикам создавать более абстрактные и гибкие решения. В Java они активно используются в сочетании с функциональными интерфейсами и лямбда-выражениями, что делает код более выразительным и поддерживаемым.

## 5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?
В пакете `java.util.function` Java предоставляет несколько функциональных интерфейсов, которые поддерживают функции высшего порядка. Эти интерфейсы позволяют передавать функции как аргументы и возвращать их в качестве результатов. Вот основные из них:

### 1. `Function<T, R>`
- **Описание**: Принимает один аргумент типа `T` и возвращает результат типа `R`.
- **Пример использования**:
  ```java
  Function<Integer, String> intToString = Object::toString;
  ```

### 2. `BiFunction<T, U, R>`
- **Описание**: Принимает два аргумента типов `T` и `U` и возвращает результат типа `R`.
- **Пример использования**:
  ```java
  BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
  ```

### 3. `Consumer<T>`
- **Описание**: Принимает один аргумент типа `T` и не возвращает значение. Используется для выполнения операций с переданным аргументом.
- **Пример использования**:
  ```java
  Consumer<String> print = System.out::println;
  ```

### 4. `BiConsumer<T, U>`
- **Описание**: Принимает два аргумента типов `T` и `U` и не возвращает значение.
- **Пример использования**:
  ```java
  BiConsumer<String, Integer> printWithLength = (s, len) -> System.out.println(s + " has length " + len);
  ```

### 5. `Predicate<T>`
- **Описание**: Принимает один аргумент типа `T` и возвращает `boolean`. Используется для проверки условий.
- **Пример использования**:
  ```java
  Predicate<String> isNotEmpty = s -> !s.isEmpty();
  ```

### 6. `BiPredicate<T, U>`
- **Описание**: Принимает два аргумента типов `T` и `U` и возвращает `boolean`.
- **Пример использования**:
  ```java
  BiPredicate<String, Integer> isLengthEqual = (s, len) -> s.length() == len;
  ```

### 7. `Supplier<T>`
- **Описание**: Не принимает аргументов и возвращает значение типа `T`. Используется для предоставления данных.
- **Пример использования**:
  ```java
  Supplier<Double> randomValue = Math::random;
  ```

### 8. `UnaryOperator<T>`
- **Описание**: Специализированный интерфейс, который принимает один аргумент типа `T` и возвращает результат того же типа `T`.
- **Пример использования**:
  ```java
  UnaryOperator<Integer> square = x -> x * x;
  ```

### 9. `BinaryOperator<T>`
- **Описание**: Специализированный интерфейс, который принимает два аргумента типа `T` и возвращает результат того же типа `T`.
- **Пример использования**:
  ```java
  BinaryOperator<Integer> multiply = (a, b) -> a * b;
  ```

### Заключение
Эти функциональные интерфейсы из пакета `java.util.function` позволяют разработчикам эффективно использовать функции высшего порядка, что делает код более гибким, модульным и удобным для чтения.

## 6. Что такое ссылки на методы?
Ссылки на методы в Java — это сокращённый способ записи лямбда-выражений, который позволяет ссылаться на существующий метод вместо его явного определения. Ссылки на методы делают код более читаемым и лаконичным, особенно когда метод уже определён и может быть использован в качестве реализации функционального интерфейса.

### Синтаксис ссылок на методы

Ссылки на методы имеют следующий общий синтаксис:

```
ClassName::methodName
```

Или для нестатических методов:

```
instance::methodName
```

### Типы ссылок на методы

1. **Ссылки на статические методы**:
   - Ссылаются на статический метод класса.
   - **Пример**:
     ```java
     import java.util.function.Function;

     public class MethodReferenceExample {
         public static void main(String[] args) {
             Function<Integer, String> intToString = MethodReferenceExample::staticMethod;
             String result = intToString.apply(123);
             System.out.println(result); // вывод: "123"
         }

         public static String staticMethod(Integer i) {
             return String.valueOf(i);
         }
     }
     ```

2. **Ссылки на нестатические методы**:
   - Ссылаются на метод экземпляра класса.
   - **Пример**:
     ```java
     import java.util.function.Consumer;

     public class InstanceMethodReferenceExample {
         public static void main(String[] args) {
             InstanceMethodReferenceExample instance = new InstanceMethodReferenceExample();
             Consumer<String> consumer = instance::instanceMethod;
             consumer.accept("Hello, Method Reference!"); // вывод: "Hello, Method Reference!"
         }

         public void instanceMethod(String s) {
             System.out.println(s);
         }
     }
     ```

3. **Ссылки на методы экземпляра конкретного объекта**:
   - Ссылаются на метод экземпляра, используя конкретный объект.
   - **Пример**:
     ```java
     import java.util.function.Consumer;

     public class SpecificObjectMethodReferenceExample {
         public static void main(String[] args) {
             SpecificObjectMethodReferenceExample obj = new SpecificObjectMethodReferenceExample();
             Consumer<String> consumer = obj::instanceMethod;
             consumer.accept("Hello, from specific object!"); // вывод: "Hello, from specific object!"
         }

         public void instanceMethod(String s) {
             System.out.println(s);
         }
     }
     ```

4. **Ссылки на конструкторы**:
   - Ссылаются на конструктор класса.
   - **Пример**:
     ```java
     import java.util.function.Supplier;

     public class ConstructorReferenceExample {
         public static void main(String[] args) {
             Supplier<ConstructorReferenceExample> supplier = ConstructorReferenceExample::new;
             ConstructorReferenceExample instance = supplier.get(); // создается новый экземпляр
             System.out.println(instance); // вывод: ConstructorReferenceExample@<hashcode>
         }
     }
     ```

### Преимущества ссылок на методы

- **Читаемость**: Код становится более понятным и лаконичным, так как ссылки на методы сокращают количество кода, необходимого для определения лямбда-выражений.
- **Переиспользование**: Вы можете использовать уже существующие методы без необходимости их повторного определения.
- **Упрощение кода**: Ссылки на методы помогают избежать избыточности и делают код более выразительным.

### Заключение

Ссылки на методы — это мощный инструмент в Java, который упрощает работу с функциональными интерфейсами и делает код более чистым и понятным. Они активно используются в сочетании с лямбда-выражениями и функциональными интерфейсами, что позволяет разработчикам создавать более элегантные решения.

##  7. Что такое ссылки на конструкторы?
Ссылки на конструкторы в Java — это специальный вид ссылок на методы, который позволяет ссылаться на конструктор класса. Они используются в контексте функциональных интерфейсов и позволяют создавать новые экземпляры объектов без явного вызова конструктора. Ссылки на конструкторы делают код более лаконичным и понятным.

### Синтаксис ссылок на конструкторы

Ссылка на конструктор имеет следующий синтаксис:

```
ClassName::new
```

### Пример использования ссылок на конструкторы

Допустим, у нас есть класс `Person`:

```java
public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

Мы можем использовать ссылку на конструктор `Person` для создания новых экземпляров этого класса, используя функциональный интерфейс `Supplier` или другие подходящие интерфейсы, такие как `Function`.

#### Пример с `Supplier`

```java
import java.util.function.Supplier;

public class ConstructorReferenceExample {
    public static void main(String[] args) {
        // Ссылка на конструктор
        Supplier<Person> personSupplier = Person::new;

        // Создание нового экземпляра Person
        Person person = personSupplier.get(); // вызов конструктора без параметров
        System.out.println("Created a new person: " + person.getName());
    }
}
```

#### Пример с `Function`

Если конструктор принимает параметры, мы можем использовать интерфейс `Function`, чтобы передать аргументы:

```java
import java.util.function.Function;

public class ConstructorReferenceWithArgsExample {
    public static void main(String[] args) {
        // Ссылка на конструктор с одним параметром
        Function<String, Person> personCreator = Person::new;

        // Создание нового экземпляра Person с именем
        Person person = personCreator.apply("Alice");
        System.out.println("Created a new person: " + person.getName()); // вывод: "Created a new person: Alice"
    }
}
```

### Преимущества ссылок на конструкторы

1. **Читаемость**: Код становится более понятным и лаконичным, так как ссылки на конструкторы избавляют от необходимости явно вызывать конструктор.
2. **Упрощение кода**: Ссылки на конструкторы позволяют легко создавать экземпляры объектов, особенно в контексте функционального программирования.
3. **Переиспользование**: Можно использовать существующие конструкторы без дублирования кода.

### Заключение

Ссылки на конструкторы — это удобный и мощный инструмент в Java, который упрощает создание объектов и улучшает читаемость кода. Они активно используются в сочетании с функциональными интерфейсами, что делает код более элегантным и выразительным.

## 8. Расскажите о зоне видимости переменных в lambda - выражениях?
В Java лямбда-выражения имеют свои особенности в отношении зоны видимости переменных, которые определяют, какие переменные могут быть использованы внутри лямбда-выражения. Основные моменты, связанные с видимостью переменных в лямбда-выражениях, включают следующее:

### 1. **Финальные и эффективно финальные переменные**

- **Финальные переменные**: Лямбда-выражения могут использовать только финальные (или фактически финальные) переменные из внешнего контекста. Это означает, что переменные, используемые в лямбда-выражении, не могут быть изменены после их инициализации.
  
- **Эффективно финальные переменные**: Если переменная не объявлена как `final`, но не изменяется после инициализации, она также может быть использована в лямбда-выражении. Это называется "эффективно финальная" переменная. Например:

```java
public class LambdaExample {
    public static void main(String[] args) {
        int number = 10; // эффективно финальная переменная
        Runnable runnable = () -> System.out.println(number); // допустимо
        runnable.run(); // вывод: 10

        // number = 20; // Ошибка компиляции, если раскомментировать
    }
}
```

### 2. **Локальные переменные**

Локальные переменные, объявленные в методе, могут быть использованы в лямбда-выражениях, только если они являются финальными или эффективно финальными. Это ограничение связано с тем, что лямбда-выражения могут быть выполнены после завершения метода, в котором они были созданы, и поэтому необходимо обеспечить неизменность этих переменных.

### 3. **Члены класса и статические переменные**

- **Члены класса**: Лямбда-выражения могут свободно использовать нестатические (экземплярные) и статические переменные класса, поскольку они имеют доступ к контексту класса.

```java
public class LambdaExample {
    private int instanceVariable = 5;
    private static int staticVariable = 10;

    public void exampleMethod() {
        Runnable runnable = () -> {
            System.out.println(instanceVariable); // доступ к экземплярной переменной
            System.out.println(staticVariable);   // доступ к статической переменной
        };
        runnable.run();
    }
}
```

### 4. **Область видимости**

Лямбда-выражения имеют доступ к переменным, находящимся в области видимости, где они были созданы. Это означает, что они могут обращаться к переменным, объявленным в методе, классе или даже в других лямбда-выражениях, если эти переменные удовлетворяют условиям (т.е. являются финальными или эффективно финальными).

### Пример

Вот пример, который иллюстрирует использование переменных в лямбда-выражениях:

```java
import java.util.Arrays;
import java.util.List;

public class LambdaScopeExample {
    public static void main(String[] args) {
        int factor = 2; // эффективно финальная переменная
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Использование переменной factor в лямбда-выражении
        numbers.forEach(number -> {
            int result = number * factor; // доступ к эффективно финальной переменной
            System.out.println(result);
        });

        // factor = 3; // Ошибка компиляции, если раскомментировать
    }
}
```

### Заключение

Зона видимости переменных в лямбда-выражениях в Java определяет, какие переменные могут быть использованы внутри этих выражений. Основное ограничение заключается в том, что лямбда-выражения могут использовать только финальные или эффективно финальные переменные, что обеспечивает безопасность и предсказуемость поведения кода. Это делает лямбда-выражения мощным инструментом для функционального программирования в Java.

##  9. Как быть в ситуации, если внутри lambda - выражения операторы могут выкинуть исключение?
В Java, когда вы работаете с лямбда-выражениями и существует вероятность возникновения исключений, необходимо учитывать, как обрабатывать эти исключения. Лямбда-выражения могут использоваться в контексте функциональных интерфейсов, и если внутри лямбда-выражения могут возникнуть проверяемые исключения (checked exceptions), вам нужно правильно их обрабатывать.

### 1. **Обработка исключений внутри лямбда-выражения**

Одним из подходов является использование блока `try-catch` внутри лямбда-выражения для обработки исключений. Например:

```java
import java.util.Arrays;
import java.util.List;

public class LambdaExceptionExample {
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "three", "4");

        // Обработка исключений внутри лямбда-выражения
        numbers.forEach(number -> {
            try {
                int value = Integer.parseInt(number); // может выбросить NumberFormatException
                System.out.println("Parsed value: " + value);
            } catch (NumberFormatException e) {
                System.err.println("Error parsing number: " + number);
            }
        });
    }
}
```

### 2. **Создание пользовательского функционального интерфейса**

Если вы хотите избежать обработки исключений внутри лямбда-выражения, вы можете создать свой собственный функциональный интерфейс, который позволяет выбрасывать исключения. Например:

```java
@FunctionalInterface
interface ThrowingConsumer<T> {
    void accept(T t) throws Exception;
}

public class CustomFunctionalInterfaceExample {
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "three", "4");

        // Использование пользовательского функционального интерфейса
        numbers.forEach(handleException(number -> {
            int value = Integer.parseInt(number); // может выбросить NumberFormatException
            System.out.println("Parsed value: " + value);
        }));
    }

    // Метод для обработки исключений
    private static <T> java.util.function.Consumer<T> handleException(ThrowingConsumer<T> consumer) {
        return t -> {
            try {
                consumer.accept(t);
            } catch (Exception e) {
                System.err.println("Error: " + e.getMessage());
            }
        };
    }
}
```

### 3. **Использование `Optional`**

Если вы хотите избежать исключений и работать с потенциально ошибочными данными, вы можете использовать класс `Optional`. Это позволяет вам обрабатывать возможные ошибки более элегантно:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class OptionalExample {
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "three", "4");

        numbers.forEach(number -> {
            Optional<Integer> parsedValue = parseInt(number);
            parsedValue.ifPresent(value -> System.out.println("Parsed value: " + value));
        });
    }

    private static Optional<Integer> parseInt(String number) {
        try {
            return Optional.of(Integer.parseInt(number));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }
}
```

### 4. **Использование библиотек**

Существуют также библиотеки, такие как Vavr, которые предоставляют более функциональный подход к обработке исключений и могут упростить работу с лямбда-выражениями и исключениями.

### Заключение

При работе с лямбда-выражениями в Java, где могут возникать исключения, важно учитывать, как вы будете их обрабатывать. Вы можете использовать блоки `try-catch`, создавать пользовательские функциональные интерфейсы, использовать `Optional`, или даже применять сторонние библиотеки для более функционального подхода. Выбор подхода зависит от конкретного случая и требований вашего приложения.

## 10. Что такое Stream API?
Stream API в Java — это мощный инструмент, введенный в Java 8, который позволяет работать с последовательностями данных (коллекциями) в функциональном стиле. Stream API предоставляет удобные и эффективные методы для обработки данных, такие как фильтрация, сортировка, преобразование и агрегация, что делает код более читаемым и лаконичным.

### Основные характеристики Stream API:

1. **Поток данных**: Stream представляет собой последовательность элементов, которые можно обрабатывать. Это может быть коллекция (например, `List`, `Set`), массив или даже ввод/вывод.

2. **Функциональный стиль**: Stream API позволяет использовать функциональные подходы к программированию, такие как лямбда-выражения и ссылки на методы. Это делает код более выразительным и удобным для чтения.

3. **Ленивая оценка**: Операции над потоками выполняются в ленивом режиме. Это означает, что вычисления выполняются только тогда, когда это необходимо (например, при вызове терминальных операций, таких как `collect()`, `forEach()`, и т.д.).

4. **Параллельная обработка**: Stream API поддерживает параллельную обработку данных, что позволяет эффективно использовать многоядерные процессоры. Вы можете легко переключиться на параллельный поток, вызвав метод `parallelStream()`.

5. **Терминальные и промежуточные операции**:
   - **Промежуточные операции**: Эти операции возвращают новый поток и могут быть объединены. Примеры: `filter()`, `map()`, `sorted()`.
   - **Терминальные операции**: Эти операции производят результат и закрывают поток. Примеры: `collect()`, `forEach()`, `count()`, `reduce()`.

### Пример использования Stream API:

Вот простой пример, демонстрирующий использование Stream API для обработки списка чисел:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamApiExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Использование Stream API для фильтрации и преобразования
        List<Integer> evenSquares = numbers.stream() // Создание потока
            .filter(n -> n % 2 == 0) // Фильтрация четных чисел
            .map(n -> n * n) // Преобразование (возведение в квадрат)
            .collect(Collectors.toList()); // Сбор результатов в список

        System.out.println("Even squares: " + evenSquares); // Вывод: Even squares: [4, 16, 36, 64, 100]
    }
}
```

### Заключение

Stream API является мощным инструментом для обработки коллекций и массивов в Java, позволяя писать более чистый, лаконичный и выразительный код. Он поддерживает функциональный стиль программирования и обеспечивает возможность эффективной параллельной обработки данных.

## 11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method,     Pipeline).
Stream API в Java использует несколько шаблонов проектирования, что позволяет ему быть гибким, расширяемым и удобным в использовании. Вот основные шаблоны проектирования, применяемые внутри Stream API:

### 1. **Builder**
Шаблон проектирования Builder используется для создания сложных объектов пошагово. В контексте Stream API это можно увидеть в методах создания потоков. Например, вы можете создать поток из коллекции с использованием метода `stream()`, а затем последовательно добавлять операции через методы, такие как `filter()`, `map()`, и т. д. Это позволяет строить цепочки операций, которые легко читаемы и понятны.

Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<String> nameStream = names.stream()
    .filter(name -> name.startsWith("A")) // Применение фильтра
    .map(String::toUpperCase); // Преобразование в верхний регистр
```

### 2. **Strategy**
Шаблон Strategy позволяет выбирать алгоритмы на лету. В Stream API это проявляется в различных операциях, таких как `filter()`, `map()`, и `reduce()`, где вы можете передать разные стратегии обработки данных (например, разные лямбда-выражения или ссылки на методы) в зависимости от ваших нужд.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
    .map(n -> n * n) // Стратегия: возведение в квадрат
    .reduce(0, Integer::sum); // Стратегия: суммирование
```

### 3. **Decorator**
Шаблон Decorator используется для добавления новых функциональных возможностей к объектам без изменения их структуры. В Stream API этот шаблон проявляется в промежуточных операциях, которые "декорируют" поток, добавляя новые операции. Например, `filter()` и `map()` создают новый поток с дополнительными свойствами, не изменяя исходный поток.

Пример:

```java
List<String> words = Arrays.asList("hello", "world", "java");
List<String> filteredWords = words.stream()
    .filter(word -> word.length() > 4) // Декорируем поток
    .map(String::toUpperCase) // Декорируем поток
    .collect(Collectors.toList());
```

### 4. **Factory Method**
Шаблон Factory Method используется для создания объектов без указания конкретного класса создаваемого объекта. В Stream API это проявляется в методах, которые создают потоки, таких как `Stream.of()`, `Arrays.stream()`, и `Collection.stream()`. Эти методы предоставляют возможность создавать потоки без необходимости знать детали реализации.

Пример:

```java
Stream<String> stream = Stream.of("a", "b", "c"); // Использование фабричного метода
```

### 5. **Pipeline**
Шаблон Pipeline используется для создания последовательности обработок данных. В Stream API каждая операция над потоком (промежуточная или терминальная) может рассматриваться как шаг в "трубопроводе" обработки данных. Это позволяет легко комбинировать различные операции и обрабатывать данные последовательно.

Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0) // Первый шаг: фильтрация
    .map(n -> n * n) // Второй шаг: преобразование
    .collect(Collectors.toList()); // Третий шаг: сбор результатов
```

### Заключение
Stream API в Java использует различные шаблоны проектирования, такие как Builder, Strategy, Decorator, Factory Method и Pipeline, чтобы обеспечить гибкость, расширяемость и удобство использования. Эти шаблоны помогают создавать чистый, лаконичный и выразительный код для обработки данных.

##  12. Объясните, где они используются в Stream API.
Шаблоны проектирования в Stream API используются для создания гибкой, расширяемой и удобной архитектуры, позволяющей эффективно обрабатывать данные. Рассмотрим, как именно каждый из шаблонов проектирования применяется в Stream API:

### 1. **Builder**
**Где используется:** Шаблон Builder в Stream API применяется для создания и конфигурации потоков. Метод `stream()` или `parallelStream()` позволяет пользователю начать процесс обработки данных, а затем добавлять операции, такие как `filter()`, `map()`, и т. д. Это позволяет строить цепочки операций, что делает код более читабельным и управляемым.

**Пример:**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("A")) // Фильтрация
    .map(String::toUpperCase) // Преобразование
    .collect(Collectors.toList()); // Сбор результатов
```

### 2. **Strategy**
**Где используется:** Шаблон Strategy используется для определения различных алгоритмов обработки данных. В Stream API это видно в методах, таких как `filter()`, `map()`, `reduce()`, где вы можете передавать различные лямбда-выражения или ссылки на методы для выполнения конкретных операций. Это позволяет менять поведение обработки данных без изменения самой структуры потока.

**Пример:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sumOfSquares = numbers.stream()
    .map(n -> n * n) // Стратегия: возведение в квадрат
    .reduce(0, Integer::sum); // Стратегия: суммирование
```

### 3. **Decorator**
**Где используется:** Шаблон Decorator в Stream API проявляется в промежуточных операциях, которые "декорируют" поток, добавляя новые функциональные возможности. Каждый вызов промежуточной операции возвращает новый поток с добавленными свойствами, что позволяет комбинировать несколько операций без изменения исходного потока.

**Пример:**
```java
List<String> words = Arrays.asList("hello", "world", "java");
List<String> processedWords = words.stream()
    .filter(word -> word.length() > 4) // Декорируем поток
    .map(String::toUpperCase) // Декорируем поток
    .collect(Collectors.toList()); // Сбор результатов
```

### 4. **Factory Method**
**Где используется:** Шаблон Factory Method используется в Stream API для создания потоков. Методы, такие как `Stream.of()`, `Arrays.stream()`, и `Collection.stream()`, позволяют создавать потоки данных без необходимости явно указывать, как именно они создаются. Это упрощает создание потоков и делает код более чистым.

**Пример:**
```java
Stream<String> stream = Stream.of("a", "b", "c"); // Использование фабричного метода
```

### 5. **Pipeline**
**Где используется:** Шаблон Pipeline используется для построения цепочки обработки данных. В Stream API каждая операция (промежуточная или терминальная) может рассматриваться как шаг в "трубопроводе". Это позволяет легко комбинировать различные операции и обрабатывать данные последовательно, что делает код более модульным и понятным.

**Пример:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0) // Первый шаг: фильтрация
    .map(n -> n * n) // Второй шаг: преобразование
    .collect(Collectors.toList()); // Третий шаг: сбор результатов
```

### Заключение
Шаблоны проектирования в Stream API помогают создать мощный инструмент для обработки данных, который легко расширять и модифицировать. Используя шаблоны, такие как Builder, Strategy, Decorator, Factory Method и Pipeline, Stream API обеспечивает гибкость и удобство в написании кода, что позволяет разработчикам эффективно работать с данными.

## 13. Что такое конвейерные и терминальные операции? 
В Java Stream API операции над потоками делятся на два основных типа: **конвейерные (промежуточные) операции** и **терминальные операции**. Эти два типа операций играют ключевую роль в обработке данных с использованием потоков. Давайте рассмотрим каждый из них более подробно.

### 1. Конвейерные (промежуточные) операции

**Определение:** Конвейерные операции (или промежуточные операции) — это операции, которые принимают поток данных и возвращают новый поток. Эти операции не выполняют фактическую обработку данных до тех пор, пока не будет вызвана терминальная операция. Они позволяют строить цепочки операций, которые могут быть выполнены последовательно.

**Примеры конвейерных операций:**
- `filter(Predicate<T> predicate)` — фильтрует элементы потока на основе заданного предиката.
- `map(Function<T, R> mapper)` — преобразует элементы потока, применяя заданную функцию.
- `distinct()` — удаляет дубликаты из потока.
- `sorted()` — сортирует элементы потока.
- `limit(long maxSize)` — ограничивает количество элементов в потоке.

**Пример:**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
Stream<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("A")) // Конвейерная операция
    .map(String::toUpperCase); // Конвейерная операция
```

### 2. Терминальные операции

**Определение:** Терминальные операции — это операции, которые инициируют фактическую обработку данных и возвращают результат. После вызова терминальной операции поток больше не может быть использован, и все промежуточные операции, которые были определены, выполняются в этот момент.

**Примеры терминальных операций:**
- `collect(Collector<T, A, R> collector)` — собирает элементы потока в коллекцию, например, в `List`, `Set` или `Map`.
- `forEach(Consumer<T> action)` — выполняет заданное действие для каждого элемента потока.
- `reduce(T identity, BinaryOperator<T> accumulator)` — выполняет редукцию элементов потока, сводя их к единственному значению.
- `count()` — возвращает количество элементов в потоке.
- `anyMatch(Predicate<T> predicate)` — проверяет, соответствует ли хотя бы один элемент заданному предикату.

**Пример:**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
long count = names.stream()
    .filter(name -> name.startsWith("A")) // Конвейерная операция
    .count(); // Терминальная операция
```

### Взаимодействие между конвейерными и терминальными операциями

Конвейерные операции могут быть объединены в цепочки, создавая "поток" обработки данных. Однако они не выполняют никаких действий, пока не будет вызвана терминальная операция, которая завершает процесс и инициирует выполнение всех предварительно определённых конвейерных операций. Это позволяет Stream API оптимизировать выполнение операций, например, с использованием ленивой обработки, что может повысить производительность.

### Заключение

Конвейерные и терминальные операции в Java Stream API позволяют разрабатывать гибкие и мощные механизмы обработки данных. Конвейерные операции позволяют строить цепочки обработки, а терминальные операции инициируют выполнение этих цепочек и возвращают результаты. Это делает Stream API удобным инструментом для работы с коллекциями и массивами в Java.

## 14. Перечислите конвейерные (промежуточные) методы Stream API.
В Java Stream API существует несколько конвейерных (промежуточных) методов, которые позволяют манипулировать потоками данных. Эти методы возвращают новый поток и могут быть объединены в цепочки для обработки данных. Вот основные конвейерные методы Stream API:

### 1. **filter(Predicate<? super T> predicate)**
Фильтрует элементы потока, оставляя только те, которые соответствуют заданному предикату.

### 2. **map(Function<? super T, ? extends R> mapper)**
Преобразует элементы потока, применяя заданную функцию к каждому элементу.

### 3. **flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)**
Преобразует элементы потока в другие потоки и объединяет их в один поток.

### 4. **distinct()**
Удаляет дубликаты из потока, оставляя только уникальные элементы.

### 5. **sorted()**
Сортирует элементы потока в естественном порядке.

### 6. **sorted(Comparator<? super T> comparator)**
Сортирует элементы потока по заданному компаратору.

### 7. **peek(Consumer<? super T> action)**
Позволяет выполнять действие для каждого элемента потока, не изменяя сам поток. Полезно для отладки.

### 8. **limit(long maxSize)**
Ограничивает количество элементов в потоке до указанного максимального размера.

### 9. **skip(long n)**
Пропускает первые `n` элементов потока и возвращает оставшиеся.

### 10. **takeWhile(Predicate<? super T> predicate)**
Возвращает элементы потока, пока заданный предикат возвращает `true`. Останавливается, как только предикат возвращает `false`.

### 11. **dropWhile(Predicate<? super T> predicate)**
Пропускает элементы потока, пока заданный предикат возвращает `true`. Возвращает оставшиеся элементы.

### 12. **mapToInt(ToIntFunction<? super T> mapper)**
Преобразует элементы потока в `int` и возвращает `IntStream`.

### 13. **mapToDouble(ToDoubleFunction<? super T> mapper)**
Преобразует элементы потока в `double` и возвращает `DoubleStream`.

### 14. **mapToLong(ToLongFunction<? super T> mapper)**
Преобразует элементы потока в `long` и возвращает `LongStream`.

### 15. **boxed()**
Преобразует примитивные потоки (например, `IntStream`, `DoubleStream`, `LongStream`) в поток объектов (`Stream<T>`).

Эти конвейерные методы позволяют эффективно обрабатывать и трансформировать данные в Java, создавая цепочки операций, которые могут быть выполнены над коллекциями и другими источниками данных.

## 15. Перечислите терминальные методы Stream API.
В Java Stream API терминальные методы (терминальные операции) инициируют фактическую обработку данных и возвращают результат. После вызова терминальной операции поток больше не может быть использован. Вот основные терминальные методы Stream API:

### 1. **collect(Collector<? super T, A, R> collector)**
Собирает элементы потока в коллекцию (например, `List`, `Set`, `Map`) или другую структуру данных.

### 2. **forEach(Consumer<? super T> action)**
Выполняет заданное действие для каждого элемента потока.

### 3. **reduce(T identity, BinaryOperator<T> accumulator)**
Сводит элементы потока к единственному значению, используя заданный бинарный оператор.

### 4. **reduce(BinaryOperator<T> accumulator)**
Сводит элементы потока к единственному значению, используя заданный бинарный оператор без начального значения.

### 5. **count()**
Возвращает количество элементов в потоке.

### 6. **anyMatch(Predicate<? super T> predicate)**
Проверяет, соответствует ли хотя бы один элемент потока заданному предикату.

### 7. **allMatch(Predicate<? super T> predicate)**
Проверяет, соответствуют ли все элементы потока заданному предикату.

### 8. **noneMatch(Predicate<? super T> predicate)**
Проверяет, не соответствует ли ни один элемент потока заданному предикату.

### 9. **findFirst()**
Возвращает первый элемент потока, если он присутствует, в виде объекта `Optional`.

### 10. **findAny()**
Возвращает любой элемент потока, если он присутствует, в виде объекта `Optional`.

### 11. **max(Comparator<? super T> comparator)**
Возвращает максимальный элемент потока по заданному компаратору в виде объекта `Optional`.

### 12. **min(Comparator<? super T> comparator)**
Возвращает минимальный элемент потока по заданному компаратору в виде объекта `Optional`.

### 13. **toArray()**
Возвращает массив, содержащий элементы потока.

### 14. **toArray(IntFunction<A[]> generator)**
Возвращает массив заданного типа, содержащий элементы потока.

### 15. **iterator()**
Возвращает итератор для элементов потока.

### 16. **reduce(Optional<T> identity, BinaryOperator<T> accumulator)**
Сводит элементы потока к единственному значению, используя заданный бинарный оператор, возвращая результат как `Optional`.

Эти терминальные методы позволяют завершить процесс обработки данных в потоках и получить результаты в различных форматах, таких как коллекции, числовые значения или отдельные элементы.

##  16. Что такое отложенный выполнение lamdba?
Отложенное выполнение (или ленивое выполнение) лямбда-выражений в Java относится к концепции, при которой выполнение кода, заключенного в лямбда-выражение, откладывается до тех пор, пока не будет фактически необходимо. Это позволяет оптимизировать производительность, особенно при работе с потоками данных и большими коллекциями, так как операции выполняются только тогда, когда это действительно нужно.

### Основные аспекты отложенного выполнения:

1. **Ленивые вычисления**:
   - При использовании Stream API и лямбда-выражений, операции могут быть отложены до тех пор, пока не будет вызвана терминальная операция (например, `collect`, `forEach`, `count` и т.д.). Промежуточные операции (такие как `filter`, `map`, `sorted`) не выполняются немедленно, а накапливаются в "конвейере".

2. **Оптимизация производительности**:
   - Отложенное выполнение позволяет избежать ненужных вычислений. Например, если вы фильтруете коллекцию и затем сортируете ее, то сортировка будет выполнена только на отфильтрованных данных.

3. **Композиция операций**:
   - Лямбда-выражения позволяют легко комбинировать операции. Поскольку операции выполняются лениво, они могут быть объединены в единую цепочку, что делает код более читаемым и понятным.

4. **Обработка больших данных**:
   - При работе с большими объемами данных отложенное выполнение позволяет обрабатывать данные по мере их необходимости, а не загружать все данные в память сразу.

### Пример:

```java
import java.util.Arrays;
import java.util.List;

public class LazyExecutionExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Промежуточные операции выполняются лениво
        numbers.stream()
            .filter(n -> {
                System.out.println("Filtering: " + n);
                return n % 2 == 0; // Оставляем только четные числа
            })
            .map(n -> {
                System.out.println("Mapping: " + n);
                return n * n; // Возвращаем квадрат числа
            })
            .forEach(n -> System.out.println("Result: " + n)); // Терминальная операция
    }
}
```

В этом примере, вывод будет происходить только тогда, когда вызывается `forEach`. То есть, фильтрация и отображение будут выполнены только для тех чисел, которые действительно будут обработаны в результате. Это демонстрирует отложенное выполнение лямбда-выражений в Java.

## 17. Что делает метод filter()?
Метод `filter()` в Java Stream API используется для фильтрации элементов потока на основе заданного предиката (условия). Он принимает в качестве аргумента функциональный интерфейс `Predicate`, который определяет логику фильтрации. Этот метод возвращает новый поток, содержащий только те элементы, которые удовлетворяют условию, заданному в предикате.

### Основные характеристики метода `filter()`:

1. **Тип возвращаемого значения**:
   - `filter()` возвращает новый поток (`Stream<T>`), который содержит только те элементы исходного потока, которые соответствуют условию.

2. **Ленивое выполнение**:
   - Как и другие промежуточные операции, `filter()` выполняется лениво. Это означает, что фактическая фильтрация не произойдет до тех пор, пока не будет вызвана терминальная операция (например, `forEach`, `collect` и т.д.).

3. **Условие фильтрации**:
   - Условие, передаваемое в `filter()`, должно быть реализовано в виде лямбда-выражения или ссылки на метод, возвращающего `true` или `false`.

### Пример использования:

```java
import java.util.Arrays;
import java.util.List;

public class FilterExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Фильтруем четные числа
        List<Integer> evenNumbers = numbers.stream()
            .filter(n -> n % 2 == 0) // Условие фильтрации
            .toList(); // Преобразуем поток обратно в список

        System.out.println("Четные числа: " + evenNumbers);
    }
}
```

### Вывод:

```
Четные числа: [2, 4, 6, 8, 10]
```

В этом примере метод `filter()` используется для выбора четных чисел из списка. Лямбда-выражение `n -> n % 2 == 0` определяет условие фильтрации, и только те числа, которые соответствуют этому условию, попадают в новый поток. После этого мы преобразуем поток в список с помощью метода `toList()`.

## 18. Что делает метод map()?
Метод `map()` в Java Stream API используется для преобразования элементов потока, применяя к каждому элементу заданную функцию. Он принимает в качестве аргумента функциональный интерфейс `Function`, который определяет, как именно каждый элемент будет преобразован. Метод `map()` возвращает новый поток, содержащий результаты применения функции к каждому элементу исходного потока.

### Основные характеристики метода `map()`:

1. **Тип возвращаемого значения**:
   - `map()` возвращает новый поток (`Stream<R>`), где `R` — это тип элементов, возвращаемых функцией, применяемой к каждому элементу исходного потока.

2. **Ленивое выполнение**:
   - Как и другие промежуточные операции, `map()` выполняется лениво. Это означает, что фактическое преобразование не произойдет до тех пор, пока не будет вызвана терминальная операция (например, `forEach`, `collect` и т.д.).

3. **Функция преобразования**:
   - Функция, передаваемая в `map()`, должна быть реализована в виде лямбда-выражения или ссылки на метод, которая принимает элемент исходного потока и возвращает преобразованный элемент.

### Пример использования:

```java
import java.util.Arrays;
import java.util.List;

public class MapExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        // Преобразуем имена в их длины
        List<Integer> nameLengths = names.stream()
            .map(name -> name.length()) // Применяем функцию для получения длины имени
            .toList(); // Преобразуем поток обратно в список

        System.out.println("Длины имен: " + nameLengths);
    }
}
```

### Вывод:

```
Длины имен: [5, 3, 7]
```

В этом примере метод `map()` используется для преобразования списка имен в список их длины. Лямбда-выражение `name -> name.length()` определяет, как каждый элемент (имя) будет преобразован (в его длину). После применения `map()` мы получаем новый поток, который затем преобразуем в список с помощью метода `toList()`.

## 19. Что делает метод flatMap()?
Метод `flatMap()` в Java Stream API используется для преобразования элементов потока, где каждый элемент может быть преобразован в другой поток, и затем объединяет все эти потоки в один. Это особенно полезно, когда вы работаете с вложенными структурами данных, такими как списки списков, и хотите "разгладить" их в один поток.

### Основные характеристики метода `flatMap()`:

1. **Тип возвращаемого значения**:
   - `flatMap()` возвращает новый поток, который содержит все элементы, полученные из потоков, возвращаемых функцией, применяемой к каждому элементу исходного потока.

2. **Ленивое выполнение**:
   - Как и другие промежуточные операции, `flatMap()` выполняется лениво. Фактическое преобразование не произойдет до тех пор, пока не будет вызвана терминальная операция (например, `forEach`, `collect` и т.д.).

3. **Функция преобразования**:
   - Функция, передаваемая в `flatMap()`, должна быть реализована в виде лямбда-выражения или ссылки на метод, которая принимает элемент исходного потока и возвращает поток элементов.

### Пример использования:

Предположим, у нас есть список списков, и мы хотим получить все элементы из этих списков в одном потоке:

```java
import java.util.Arrays;
import java.util.List;

public class FlatMapExample {
    public static void main(String[] args) {
        List<List<String>> listOfLists = Arrays.asList(
            Arrays.asList("Apple", "Banana"),
            Arrays.asList("Orange", "Grape"),
            Arrays.asList("Pineapple", "Mango")
        );

        // Преобразуем список списков в один поток строк
        List<String> allFruits = listOfLists.stream()
            .flatMap(List::stream) // Преобразуем каждый вложенный список в поток и объединяем
            .toList(); // Преобразуем поток обратно в список

        System.out.println("Все фрукты: " + allFruits);
    }
}
```

### Вывод:

```
Все фрукты: [Apple, Banana, Orange, Grape, Pineapple, Mango]
```

В этом примере метод `flatMap()` используется для преобразования списка списков фруктов в один поток строк. Метод `List::stream` преобразует каждый вложенный список в поток, а затем `flatMap()` объединяет все эти потоки в один. В результате мы получаем плоский список всех фруктов, который затем преобразуем в обычный список с помощью метода `toList()`.

## 20. Что делает метод collect?
Метод `collect()` в Java Stream API используется для преобразования элементов потока в более удобную структуру данных, такую как список, множество или карту. Это терминальная операция, которая завершает потоковую обработку, собирая результаты в определенный контейнер.

### Основные характеристики метода `collect()`:

1. **Тип возвращаемого значения**:
   - Метод `collect()` возвращает объект, который соответствует указанному коллектору (например, `List`, `Set`, `Map` и т.д.).

2. **Использование коллекторов**:
   - `collect()` принимает в качестве аргумента реализацию интерфейса `Collector`. В Java есть несколько встроенных коллекторов, таких как:
     - `Collectors.toList()`: собирает элементы в список.
     - `Collectors.toSet()`: собирает элементы в множество.
     - `Collectors.toMap()`: собирает элементы в карту.
     - `Collectors.joining()`: объединяет строки в одну строку.

3. **Терминальная операция**:
   - `collect()` является терминальной операцией, что означает, что она завершает поток и инициирует выполнение всех предыдущих операций.

### Примеры использования:

1. **Сбор элементов в список**:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class CollectExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        // Собираем имена в список
        List<String> collectedNames = names.stream()
            .collect(Collectors.toList());

        System.out.println("Собранные имена: " + collectedNames);
    }
}
```

### Вывод:

```
Собранные имена: [Alice, Bob, Charlie]
```

2. **Сбор элементов в множество**:

```java
import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

public class CollectToSetExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Alice");

        // Собираем имена в множество (дубликаты будут удалены)
        Set<String> collectedNames = names.stream()
            .collect(Collectors.toSet());

        System.out.println("Собранные имена в множестве: " + collectedNames);
    }
}
```

### Вывод:

```
Собранные имена в множестве: [Alice, Bob, Charlie]
```

3. **Сбор элементов в строку**:

```java
import java.util.Arrays;
import java.util.stream.Collectors;

public class CollectJoiningExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        // Объединяем имена в одну строку
        String joinedNames = names.stream()
            .collect(Collectors.joining(", "));

        System.out.println("Объединенные имена: " + joinedNames);
    }
}
```

### Вывод:

```
Объединенные имена: Alice, Bob, Charlie
```

В этих примерах метод `collect()` используется для сбора элементов потока в различные структуры данных, демонстрируя его гибкость и мощность в обработке и агрегации данных.

##   21. Что делает метод findFirst?
Метод `findFirst()` в Java Stream API используется для получения первого элемента из потока. Он является терминальной операцией, которая завершает потоковую обработку и возвращает результат в виде объекта `Optional`. Если поток содержит элементы, `findFirst()` вернет первый элемент, иначе вернет пустой `Optional`.

### Основные характеристики метода `findFirst()`:

1. **Возвращаемое значение**:
   - Метод возвращает объект типа `Optional<T>`, где `T` — тип элементов в потоке. Это позволяет безопасно работать с возможным отсутствием значения.

2. **Терминальная операция**:
   - `findFirst()` завершает поток и инициирует выполнение всех предыдущих операций.

3. **Не ленивое выполнение**:
   - В отличие от промежуточных операций, `findFirst()` выполняется немедленно, как только вызывается, и возвращает первый элемент, который будет найден в потоке.

4. **Порядок элементов**:
   - Если поток является упорядоченным (например, получен из списка), `findFirst()` вернет первый элемент в порядке следования. Если поток неупорядочен, поведение может быть непредсказуемым.

### Пример использования:

1. **Поиск первого элемента в списке**:

```java
import java.util.Arrays;
import java.util.Optional;

public class FindFirstExample {
    public static void main(String[] args) {
        // Создаем поток из списка строк
        Optional<String> firstElement = Arrays.asList("Apple", "Banana", "Cherry")
            .stream()
            .findFirst();

        // Проверяем и выводим первый элемент
        firstElement.ifPresent(System.out::println);
    }
}
```

### Вывод:

```
Apple
```

2. **Поиск первого четного числа**:

```java
import java.util.Arrays;
import java.util.Optional;

public class FindFirstEvenExample {
    public static void main(String[] args) {
        // Создаем поток из массива чисел
        Optional<Integer> firstEven = Arrays.asList(1, 3, 5, 2, 4)
            .stream()
            .filter(n -> n % 2 == 0) // Фильтруем четные числа
            .findFirst(); // Ищем первое четное число

        // Проверяем и выводим результат
        firstEven.ifPresentOrElse(
            System.out::println,
            () -> System.out.println("Четные числа не найдены")
        );
    }
}
```

### Вывод:

```
2
```

3. **Поиск первого элемента в пустом потоке**:

```java
import java.util.Optional;
import java.util.stream.Stream;

public class FindFirstEmptyExample {
    public static void main(String[] args) {
        // Создаем пустой поток
        Optional<String> firstElement = Stream.empty().findFirst();

        // Проверяем и выводим результат
        System.out.println("Первый элемент: " + firstElement.orElse("Не найден"));
    }
}
```

### Вывод:

```
Первый элемент: Не найден
```

В этих примерах метод `findFirst()` демонстрирует свою способность находить первый элемент в потоке, а также работу с пустыми потоками, что позволяет избежать `NullPointerException` благодаря использованию `Optional`.

##  22. Что делает метод reduce?
Метод `reduce()` в Java Stream API используется для агрегирования элементов потока в одно значение с помощью заданной бинарной операции. Это терминальная операция, которая позволяет свести поток к единственному результату, применяя операцию к элементам последовательно.

### Основные характеристики метода `reduce()`:

1. **Возвращаемое значение**:
   - Метод возвращает объект типа `Optional<T>`, где `T` — тип элементов в потоке. Если поток пуст, возвращается пустой `Optional`.

2. **Бинарная операция**:
   - Метод принимает в качестве аргумента бинарную операцию, которая определяет, как два элемента комбинируются в один. Эта операция должна быть ассоциативной, чтобы гарантировать правильный результат при параллельной обработке.

3. **Перегрузки**:
   - Метод `reduce()` имеет несколько перегрузок:
     - `reduce(T identity, BinaryOperator<T> accumulator)`: принимает начальное значение (идентичность) и бинарную операцию.
     - `reduce(BinaryOperator<T> accumulator)`: принимает только бинарную операцию.

4. **Терминальная операция**:
   - `reduce()` завершает поток и инициирует выполнение всех предыдущих операций.

### Примеры использования:

1. **Суммирование чисел**:

```java
import java.util.Arrays;

public class ReduceSumExample {
    public static void main(String[] args) {
        int sum = Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .reduce(0, (a, b) -> a + b); // Суммируем элементы

        System.out.println("Сумма: " + sum);
    }
}
```

### Вывод:

```
Сумма: 15
```

2. **Умножение чисел**:

```java
import java.util.Arrays;

public class ReduceMultiplyExample {
    public static void main(String[] args) {
        int product = Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .reduce(1, (a, b) -> a * b); // Умножаем элементы

        System.out.println("Произведение: " + product);
    }
}
```

### Вывод:

```
Произведение: 120
```

3. **Поиск максимального значения**:

```java
import java.util.Arrays;
import java.util.Optional;

public class ReduceMaxExample {
    public static void main(String[] args) {
        Optional<Integer> max = Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .reduce(Integer::max); // Находим максимальное значение

        max.ifPresent(value -> System.out.println("Максимальное значение: " + value));
    }
}
```

### Вывод:

```
Максимальное значение: 5
```

4. **Объединение строк**:

```java
import java.util.Arrays;

public class ReduceStringExample {
    public static void main(String[] args) {
        String concatenated = Arrays.asList("Hello", " ", "World", "!")
            .stream()
            .reduce("", (a, b) -> a + b); // Объединяем строки

        System.out.println("Объединенная строка: " + concatenated);
    }
}
```

### Вывод:

```
Объединенная строка: Hello World!
```

В этих примерах метод `reduce()` демонстрирует свою способность агрегировать элементы потока в одно значение, используя различные операции, такие как сложение, умножение, нахождение максимума и объединение строк. Это делает `reduce()` мощным инструментом для выполнения операций агрегации в функциональном стиле.

## 23. Что делают методы min и max?
Методы `min()` и `max()` в Java Stream API используются для нахождения минимального и максимального значений в потоке элементов. Эти методы являются терминальными операциями и возвращают результаты в виде объекта `Optional`, что позволяет безопасно обрабатывать случаи, когда поток может быть пустым.

### Основные характеристики методов `min()` и `max()`:

1. **Возвращаемое значение**:
   - Оба метода возвращают объект типа `Optional<T>`, где `T` — тип элементов в потоке. Это позволяет избежать `NullPointerException` при работе с пустыми потоками.

2. **Сравнительная функция**:
   - Методы принимают в качестве аргумента компаратор (интерфейс `Comparator<T>`), который определяет порядок элементов. Компаратор должен быть реализован таким образом, чтобы правильно сравнивать элементы.

3. **Терминальная операция**:
   - Оба метода завершают поток и инициируют выполнение всех предыдущих операций.

### Примеры использования:

1. **Нахождение минимального значения**:

```java
import java.util.Arrays;
import java.util.Optional;

public class MinExample {
    public static void main(String[] args) {
        Optional<Integer> min = Arrays.asList(3, 5, 1, 4, 2)
            .stream()
            .min(Integer::compareTo); // Находим минимальное значение

        min.ifPresent(value -> System.out.println("Минимальное значение: " + value));
    }
}
```

### Вывод:

```
Минимальное значение: 1
```

2. **Нахождение максимального значения**:

```java
import java.util.Arrays;
import java.util.Optional;

public class MaxExample {
    public static void main(String[] args) {
        Optional<Integer> max = Arrays.asList(3, 5, 1, 4, 2)
            .stream()
            .max(Integer::compareTo); // Находим максимальное значение

        max.ifPresent(value -> System.out.println("Максимальное значение: " + value));
    }
}
```

### Вывод:

```
Максимальное значение: 5
```

3. **Нахождение минимальной и максимальной строки**:

```java
import java.util.Arrays;
import java.util.Optional;

public class MinMaxStringExample {
    public static void main(String[] args) {
        Optional<String> minString = Arrays.asList("apple", "banana", "kiwi", "orange")
            .stream()
            .min(String::compareTo); // Находим строку с минимальным значением

        Optional<String> maxString = Arrays.asList("apple", "banana", "kiwi", "orange")
            .stream()
            .max(String::compareTo); // Находим строку с максимальным значением

        minString.ifPresent(value -> System.out.println("Минимальная строка: " + value));
        maxString.ifPresent(value -> System.out.println("Максимальная строка: " + value));
    }
}
```

### Вывод:

```
Минимальная строка: apple
Максимальная строка: orange
```

4. **Обработка пустого потока**:

```java
import java.util.Optional;
import java.util.stream.Stream;

public class MinMaxEmptyExample {
    public static void main(String[] args) {
        Optional<Integer> min = Stream.empty().min(Integer::compareTo);
        Optional<Integer> max = Stream.empty().max(Integer::compareTo);

        System.out.println("Минимальное значение: " + min.orElse(-1)); // Возвращает -1, если поток пуст
        System.out.println("Максимальное значение: " + max.orElse(-1)); // Возвращает -1, если поток пуст
    }
}
```

### Вывод:

```
Минимальное значение: -1
Максимальное значение: -1
```

В этих примерах методы `min()` и `max()` демонстрируют свою способность находить минимальные и максимальные значения в потоке, используя компараторы для определения порядка. Эти методы полезны для выполнения операций по поиску крайних значений в коллекциях данных.

## 24. Что делают методы count, sum, average?
Методы `count()`, `sum()` и `average()` в Java Stream API используются для выполнения различных агрегирующих операций над элементами потока. Они позволяют получить количество элементов, сумму значений и среднее значение соответственно. Давайте рассмотрим каждый из них подробнее.

### 1. Метод `count()`

- **Описание**: Метод `count()` возвращает количество элементов в потоке. Это терминальная операция, которая завершает поток и инициирует выполнение всех предыдущих операций.
- **Возвращаемое значение**: Возвращает значение типа `long`, представляющее количество элементов в потоке.

#### Пример использования:

```java
import java.util.Arrays;

public class CountExample {
    public static void main(String[] args) {
        long count = Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .count(); // Считаем количество элементов

        System.out.println("Количество элементов: " + count);
    }
}
```

### Вывод:

```
Количество элементов: 5
```

### 2. Метод `sum()`

- **Описание**: Метод `sum()` используется для вычисления суммы элементов потока. Этот метод доступен только для потоков числовых типов (например, `IntStream`, `LongStream`, `DoubleStream`).
- **Возвращаемое значение**: Возвращает сумму элементов потока, соответствующего типу.

#### Пример использования:

```java
import java.util.Arrays;

public class SumExample {
    public static void main(String[] args) {
        int sum = Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .mapToInt(Integer::intValue) // Преобразуем в IntStream
            .sum(); // Считаем сумму

        System.out.println("Сумма: " + sum);
    }
}
```

### Вывод:

```
Сумма: 15
```

### 3. Метод `average()`

- **Описание**: Метод `average()` вычисляет среднее значение элементов потока. Как и `sum()`, этот метод доступен только для потоков числовых типов.
- **Возвращаемое значение**: Возвращает объект типа `OptionalDouble`, который содержит среднее значение, если поток не пустой. Если поток пуст, возвращается пустой `OptionalDouble`.

#### Пример использования:

```java
import java.util.Arrays;
import java.util.OptionalDouble;

public class AverageExample {
    public static void main(String[] args) {
        OptionalDouble average = Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .mapToInt(Integer::intValue) // Преобразуем в IntStream
            .average(); // Вычисляем среднее значение

        average.ifPresent(value -> System.out.println("Среднее значение: " + value));
    }
}
```

### Вывод:

```
Среднее значение: 3.0
```

### Обработка пустого потока с `average()`:

```java
import java.util.OptionalDouble;
import java.util.stream.Stream;

public class AverageEmptyExample {
    public static void main(String[] args) {
        OptionalDouble average = Stream.empty().average(); // Пустой поток

        System.out.println("Среднее значение: " + average.orElse(-1)); // Возвращает -1, если поток пуст
    }
}
```

### Вывод:

```
Среднее значение: -1.0
```

### Итог

- **`count()`**: Подсчитывает количество элементов в потоке.
- **`sum()`**: Вычисляет сумму элементов (доступен для числовых потоков).
- **`average()`**: Вычисляет среднее значение элементов (доступен для числовых потоков и возвращает `OptionalDouble`).

Эти методы являются полезными инструментами для выполнения базовых агрегирующих операций над потоками данных в Java.

## 25. Что делают методы forEach и peek?
Методы `forEach` и `peek` в Java Stream API используются для обработки элементов потока, но они имеют разные цели и поведение. Давайте рассмотрим каждый из них подробнее.

### 1. Метод `forEach`

- **Описание**: Метод `forEach` является терминальной операцией, которая применяется к каждому элементу потока и выполняет заданное действие. Он используется, чтобы выполнить определённое действие для каждого элемента потока, например, вывести его на экран или изменить его состояние.
  
- **Возвращаемое значение**: Метод `forEach` не возвращает никакого значения (возвращает `void`), и он завершает поток.

#### Пример использования:

```java
import java.util.Arrays;

public class ForEachExample {
    public static void main(String[] args) {
        Arrays.asList("apple", "banana", "orange")
            .stream()
            .forEach(fruit -> System.out.println(fruit)); // Выводим каждый элемент на экран
    }
}
```

### Вывод:

```
apple
banana
orange
```

### 2. Метод `peek`

- **Описание**: Метод `peek` используется для промежуточной обработки элементов потока. Он позволяет "заглянуть" в поток и выполнить действие для каждого элемента, не изменяя сам поток. Это полезно для отладки или логирования, когда нужно увидеть, какие элементы проходят через поток, не изменяя их.

- **Возвращаемое значение**: Метод `peek` возвращает новый поток, который содержит те же элементы, что и исходный поток, и применяется к ним заданное действие.

#### Пример использования:

```java
import java.util.Arrays;

public class PeekExample {
    public static void main(String[] args) {
        Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .peek(num -> System.out.println("Текущий элемент: " + num)) // "Заглядываем" в поток
            .map(num -> num * 2) // Применяем преобразование
            .forEach(result -> System.out.println("Результат: " + result)); // Выводим результат
    }
}
```

### Вывод:

```
Текущий элемент: 1
Результат: 2
Текущий элемент: 2
Результат: 4
Текущий элемент: 3
Результат: 6
Текущий элемент: 4
Результат: 8
Текущий элемент: 5
Результат: 10
```

### Ключевые отличия:

- **Терминальность**:
  - `forEach`: терминальная операция, которая завершает поток и не возвращает нового потока.
  - `peek`: промежуточная операция, которая возвращает новый поток и позволяет продолжать дальнейшую обработку.

- **Использование**:
  - `forEach`: используется для выполнения действия над каждым элементом, когда дальнейшая обработка не требуется.
  - `peek`: используется для отладки и промежуточной обработки, когда нужно видеть элементы потока, но не изменять их.

### Итог

- **`forEach`**: применяется для выполнения действия над каждым элементом потока и завершает его.
- **`peek`**: используется для промежуточной обработки и позволяет "заглянуть" в поток, не изменяя его, что полезно для отладки.

## 26. Что делают методы skip и limit?
Методы `skip` и `limit` в Java Stream API используются для управления количеством элементов в потоке, позволяя пропускать определенное количество элементов или ограничивать количество возвращаемых элементов. Давайте рассмотрим каждый из них подробнее.

### 1. Метод `skip`

- **Описание**: Метод `skip` пропускает указанное количество элементов в потоке и возвращает новый поток, содержащий оставшиеся элементы. Это полезно, когда нужно игнорировать первые несколько элементов.

- **Возвращаемое значение**: Возвращает новый поток, который содержит элементы, начиная с указанного индекса.

#### Пример использования:

```java
import java.util.Arrays;

public class SkipExample {
    public static void main(String[] args) {
        Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .skip(2) // Пропускаем первые 2 элемента
            .forEach(System.out::println); // Выводим оставшиеся элементы
    }
}
```

### Вывод:

```
3
4
5
```

### 2. Метод `limit`

- **Описание**: Метод `limit` ограничивает количество элементов в потоке до указанного значения. Это полезно, когда необходимо получить только определенное количество элементов из потока.

- **Возвращаемое значение**: Возвращает новый поток, содержащий не более указанного количества элементов из исходного потока.

#### Пример использования:

```java
import java.util.Arrays;

public class LimitExample {
    public static void main(String[] args) {
        Arrays.asList(1, 2, 3, 4, 5)
            .stream()
            .limit(3) // Ограничиваем количество элементов до 3
            .forEach(System.out::println); // Выводим элементы
    }
}
```

### Вывод:

```
1
2
3
```

### Комбинирование `skip` и `limit`

Методы `skip` и `limit` могут быть использованы вместе для более сложной обработки потоков. Например, можно пропустить определенное количество элементов и затем ограничить количество возвращаемых:

```java
import java.util.Arrays;

public class SkipLimitExample {
    public static void main(String[] args) {
        Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
            .stream()
            .skip(3) // Пропускаем первые 3 элемента
            .limit(4) // Ограничиваем количество элементов до 4
            .forEach(System.out::println); // Выводим элементы
    }
}
```

### Вывод:

```
4
5
6
7
```

### Итог

- **`skip(n)`**: Пропускает первые `n` элементов в потоке и возвращает новый поток с оставшимися элементами.
- **`limit(n)`**: Ограничивает количество элементов в потоке до `n` и возвращает новый поток с указанным количеством элементов.

Эти методы полезны для управления потоком данных и позволяют более точно контролировать, какие элементы будут обработаны.

##  27. Что делают методы allMatch(), noneMatch() и anyMatch()?
Методы `allMatch()`, `noneMatch()` и `anyMatch()` в Java Stream API используются для проверки соответствия элементов потока заданному предикату (условию). Эти методы являются терминальными операциями и возвращают логическое значение (`boolean`). Давайте рассмотрим каждый из них подробнее.

### 1. Метод `allMatch`

- **Описание**: Метод `allMatch` проверяет, соответствуют ли все элементы потока заданному предикату. Если все элементы соответствуют, метод возвращает `true`; если хотя бы один элемент не соответствует, возвращается `false`. Если поток пуст, также возвращается `true`.

- **Возвращаемое значение**: `boolean`

#### Пример использования:

```java
import java.util.Arrays;

public class AllMatchExample {
    public static void main(String[] args) {
        boolean allEven = Arrays.asList(2, 4, 6, 8)
            .stream()
            .allMatch(num -> num % 2 == 0); // Проверяем, все ли числа четные

        System.out.println("Все числа четные: " + allEven); // Вывод: true
    }
}
```

### 2. Метод `noneMatch`

- **Описание**: Метод `noneMatch` проверяет, не соответствует ли ни один из элементов потока заданному предикату. Если ни один элемент не соответствует, метод возвращает `true`; если хотя бы один элемент соответствует, возвращается `false`. Если поток пуст, также возвращается `true`.

- **Возвращаемое значение**: `boolean`

#### Пример использования:

```java
import java.util.Arrays;

public class NoneMatchExample {
    public static void main(String[] args) {
        boolean noneOdd = Arrays.asList(2, 4, 6, 8)
            .stream()
            .noneMatch(num -> num % 2 != 0); // Проверяем, нет ли нечетных чисел

        System.out.println("Нет нечетных чисел: " + noneOdd); // Вывод: true
    }
}
```

### 3. Метод `anyMatch`

- **Описание**: Метод `anyMatch` проверяет, соответствует ли хотя бы один элемент потока заданному предикату. Если хотя бы один элемент соответствует, метод возвращает `true`; если ни один элемент не соответствует, возвращается `false`. Если поток пуст, возвращается `false`.

- **Возвращаемое значение**: `boolean`

#### Пример использования:

```java
import java.util.Arrays;

public class AnyMatchExample {
    public static void main(String[] args) {
        boolean anyOdd = Arrays.asList(2, 4, 5, 8)
            .stream()
            .anyMatch(num -> num % 2 != 0); // Проверяем, есть ли нечетные числа

        System.out.println("Есть нечетные числа: " + anyOdd); // Вывод: true
    }
}
```

### Итог

- **`allMatch(predicate)`**: Возвращает `true`, если все элементы потока соответствуют заданному предикату; возвращает `false`, если хотя бы один элемент не соответствует.
- **`noneMatch(predicate)`**: Возвращает `true`, если ни один элемент потока не соответствует заданному предикату; возвращает `false`, если хотя бы один элемент соответствует.
- **`anyMatch(predicate)`**: Возвращает `true`, если хотя бы один элемент потока соответствует заданному предикату; возвращает `false`, если ни один элемент не соответствует.

Эти методы полезны для проверки условий на коллекциях данных и позволяют эффективно фильтровать информацию в потоках.

## 28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?
Методы `mapToInt()`, `flatMapToInt()` и `mapToObj()` в Java Stream API используются для преобразования элементов потока в различные формы. Эти методы позволяют изменять тип элементов потока и выполнять операции над ними. Давайте подробнее рассмотрим каждый из этих методов.

### 1. Метод `mapToInt()`

- **Описание**: Метод `mapToInt` используется для преобразования элементов потока в примитивные типы `int`. Он принимает предикат, который определяет, как каждый элемент должен быть преобразован, и возвращает `IntStream`.

- **Возвращаемое значение**: `IntStream`

#### Пример использования:

```java
import java.util.Arrays;

public class MapToIntExample {
    public static void main(String[] args) {
        int sum = Arrays.asList("1", "2", "3", "4")
            .stream()
            .mapToInt(Integer::parseInt) // Преобразуем строки в целые числа
            .sum(); // Суммируем элементы

        System.out.println("Сумма: " + sum); // Вывод: Сумма: 10
    }
}
```

### 2. Метод `flatMapToInt()`

- **Описание**: Метод `flatMapToInt` используется для преобразования элементов потока в примитивные типы `int`, но в отличие от `mapToInt`, он может обрабатывать вложенные структуры. Он принимает функцию, которая возвращает `IntStream`, и "разворачивает" эти потоки в один поток `int`.

- **Возвращаемое значение**: `IntStream`

#### Пример использования:

```java
import java.util.Arrays;
import java.util.List;

public class FlatMapToIntExample {
    public static void main(String[] args) {
        List<List<Integer>> listOfLists = Arrays.asList(
            Arrays.asList(1, 2, 3),
            Arrays.asList(4, 5),
            Arrays.asList(6, 7, 8, 9)
        );

        int sum = listOfLists.stream()
            .flatMapToInt(list -> list.stream().mapToInt(Integer::intValue)) // "Разворачиваем" вложенные списки
            .sum(); // Суммируем элементы

        System.out.println("Сумма: " + sum); // Вывод: Сумма: 45
    }
}
```

### 3. Метод `mapToObj()`

- **Описание**: Метод `mapToObj` используется для преобразования элементов потока в объекты. Он принимает функцию, которая определяет, как каждый элемент должен быть преобразован, и возвращает `Stream<T>`.

- **Возвращаемое значение**: `Stream<T>`

#### Пример использования:

```java
import java.util.Arrays;

public class MapToObjExample {
    public static void main(String[] args) {
        String result = Arrays.asList(1, 2, 3, 4)
            .stream()
            .mapToObj(String::valueOf) // Преобразуем целые числа в строки
            .reduce("", (s1, s2) -> s1 + s2); // Объединяем строки

        System.out.println("Результат: " + result); // Вывод: Результат: 1234
    }
}
```

### Итог

- **`mapToInt(ToIntFunction<? super T> mapper)`**: Преобразует элементы потока в `IntStream` с использованием заданной функции.
- **`flatMapToInt(ToIntFunction<? super T> mapper)`**: Преобразует элементы потока, возвращая `IntStream`, и разворачивает вложенные потоки в один поток `int`.
- **`mapToObj(Function<? super T, ? extends R> mapper)`**: Преобразует элементы потока в объекты, возвращая `Stream<R>`.

Эти методы позволяют гибко управлять преобразованием данных в потоках и обеспечивают мощные инструменты для работы с коллекциями.

## 29. Что такое числовой поток?
Числовой поток (numeric stream) в Java Stream API — это специальный тип потока, предназначенный для работы с примитивными числовыми значениями. Он обеспечивает оптимизированные операции для обработки чисел, что позволяет избежать ненужной упаковки и распаковки объектов (например, `Integer`, `Double` и т.д.), что может привести к снижению производительности.

Java предоставляет три основных типа числовых потоков:

1. **IntStream**: Поток целых чисел (`int`).
2. **LongStream**: Поток длинных целых чисел (`long`).
3. **DoubleStream**: Поток чисел с плавающей точкой двойной точности (`double`).

### Основные характеристики числовых потоков:

- **Преимущества**: Числовые потоки позволяют выполнять операции, такие как суммирование, вычисление среднего значения и другие агрегирующие функции, более эффективно, чем с использованием объектов-оберток. Они также предоставляют специальные методы, которые оптимизированы для работы с примитивами.

- **Методы**: Числовые потоки имеют свои уникальные методы, такие как `sum()`, `average()`, `min()`, `max()`, `count()` и другие, которые позволяют выполнять операции непосредственно над примитивными значениями.

- **Создание**: Числовые потоки можно создавать из коллекций, массивов или с помощью статических методов, таких как `IntStream.range()`, `LongStream.of()`, и т.д.

### Примеры использования

#### Пример создания и использования `IntStream`:

```java
import java.util.stream.IntStream;

public class IntStreamExample {
    public static void main(String[] args) {
        int sum = IntStream.range(1, 5) // Создание потока чисел от 1 до 4
            .sum(); // Суммируем элементы

        System.out.println("Сумма: " + sum); // Вывод: Сумма: 10
    }
}
```

#### Пример использования `DoubleStream`:

```java
import java.util.stream.DoubleStream;

public class DoubleStreamExample {
    public static void main(String[] args) {
        double average = DoubleStream.of(1.0, 2.0, 3.0, 4.0, 5.0) // Создание потока двойных чисел
            .average() // Вычисляем среднее
            .orElse(0.0); // Значение по умолчанию, если поток пуст

        System.out.println("Среднее: " + average); // Вывод: Среднее: 3.0
    }
}
```

### Заключение

Числовые потоки в Java Stream API предоставляют удобный и эффективный способ работы с примитивными числовыми значениями. Они позволяют выполнять различные операции над числами без необходимости упаковки в объекты, что делает их более производительными для задач, связанных с числовыми вычислениями.


## 30. Чем отличается Stream<Integer> от IntStream<int>?
`Stream<Integer>` и `IntStream` в Java представляют собой два разных типа потоков, каждый из которых предназначен для работы с различными типами данных. Вот основные отличия между ними:

### 1. Тип данных

- **`Stream<Integer>`**:
  - Это поток объектов, который работает с типом `Integer`, который является оберткой для примитивного типа `int`.
  - В этом случае каждый элемент потока является объектом, что может привести к дополнительным затратам на упаковку и распаковку (autoboxing и unboxing) при работе с примитивами.

- **`IntStream`**:
  - Это специализированный поток, который работает непосредственно с примитивным типом `int`.
  - Он оптимизирован для работы с числовыми значениями и избегает накладных расходов, связанных с использованием объектов-оберток.

### 2. Производительность

- **`Stream<Integer>`**:
  - Из-за необходимости упаковки и распаковки значений `int` в объекты `Integer`, производительность может быть ниже, особенно если вы работаете с большим количеством чисел.

- **`IntStream`**:
  - Этот поток предлагает более высокую производительность для операций с числами, так как работает с примитивами напрямую, без необходимости упаковки.

### 3. Доступные методы

- **`Stream<Integer>`**:
  - Методы, доступные в `Stream<Integer>`, являются общими для всех объектов, такие как `map()`, `filter()`, `reduce()`, и т.д.
  - Для выполнения операций, специфичных для чисел, вам может понадобиться использовать методы, которые работают с `int`, например, через `mapToInt()`.

- **`IntStream`**:
  - `IntStream` предоставляет специальные методы, такие как `sum()`, `average()`, `min()`, `max()`, которые предназначены для работы с примитивными типами и обеспечивают более эффективные операции.

### Примеры

#### Пример использования `Stream<Integer>`:

```java
import java.util.Arrays;
import java.util.List;

public class StreamIntegerExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        int sum = numbers.stream()
                         .mapToInt(Integer::intValue) // Преобразуем в IntStream
                         .sum(); // Суммируем элементы

        System.out.println("Сумма: " + sum); // Вывод: Сумма: 15
    }
}
```

#### Пример использования `IntStream`:

```java
import java.util.stream.IntStream;

public class IntStreamExample {
    public static void main(String[] args) {
        int sum = IntStream.range(1, 6) // Создаем поток от 1 до 5
                           .sum(); // Суммируем элементы

        System.out.println("Сумма: " + sum); // Вывод: Сумма: 15
    }
}
```

### Заключение

В общем, если вам нужно работать с примитивными целыми числами и выполнять числовые операции, `IntStream` является более подходящим выбором благодаря своей оптимизации и отсутствию накладных расходов на упаковку. Если же вы работаете с коллекциями объектов и вам нужны методы, доступные для объектов, используйте `Stream<Integer>`.

## 31. Что делает метод boxed?
Метод `boxed()` в Java Stream API используется для преобразования специализированного потока примитивных типов (например, `IntStream`, `LongStream`, `DoubleStream`) в поток объектов соответствующего типа (например, `Stream<Integer>`, `Stream<Long>`, `Stream<Double>`). Этот метод позволяет работать с примитивами как с объектами, что может быть полезно в различных ситуациях, например, когда требуется использовать методы, специфичные для объектов.

### Пример использования `boxed()`

Рассмотрим пример, в котором мы создаем `IntStream`, а затем преобразуем его в `Stream<Integer>` с помощью метода `boxed()`:

```java
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class BoxedExample {
    public static void main(String[] args) {
        IntStream intStream = IntStream.range(1, 6); // Создание IntStream от 1 до 5

        // Преобразование IntStream в Stream<Integer>
        Stream<Integer> boxedStream = intStream.boxed();

        // Выводим элементы потока
        boxedStream.forEach(System.out::println);
    }
}
```

### Вывод
Этот код создаст поток целых чисел от 1 до 5, затем преобразует его в поток объектов `Integer` и выведет каждое число на экран.

### Когда использовать `boxed()`

- **Когда требуется работать с методами, которые принимают `Stream<T>`**: Если у вас есть методы, которые требуют поток объектов, но у вас есть поток примитивов, вам нужно использовать `boxed()`.
- **При работе с коллекциями**: Если вы хотите собрать элементы из потока примитивов в коллекцию (например, `List<Integer>`), вам нужно сначала преобразовать поток примитивов в поток объектов с помощью `boxed()`.

### Заключение

Метод `boxed()` является полезным инструментом для преобразования специализированных потоков примитивных типов в потоки объектов, что позволяет использовать преимущества работы с объектами в Java Stream API.

## 32. Возможно ли прервать выполнение потока по аналогии с break?
В Java Stream API нет прямого эквивалента оператора `break`, который используется в традиционных циклах, таких как `for` или `while`. Однако, существуют способы прервать выполнение потока или остановить его обработку в зависимости от ситуации. Вот несколько подходов:

### 1. Использование `filter()`

Если вы хотите прервать обработку на основании условия, вы можете использовать метод `filter()`, чтобы отфильтровать элементы, которые вам не нужны. Это не совсем то же самое, что и `break`, но позволяет контролировать, какие элементы будут обрабатываться дальше.

```java
import java.util.stream.IntStream;

public class FilterExample {
    public static void main(String[] args) {
        IntStream.range(1, 10)
                 .filter(n -> n < 5) // Прерываем обработку, когда n >= 5
                 .forEach(System.out::println); // Вывод: 1, 2, 3, 4
    }
}
```

### 2. Использование `findFirst()` или `findAny()`

Если вам нужно остановить обработку после нахождения первого подходящего элемента, вы можете использовать методы `findFirst()` или `findAny()`. Эти методы прекращают обработку, как только находят первый элемент, удовлетворяющий условию.

```java
import java.util.OptionalInt;
import java.util.stream.IntStream;

public class FindFirstExample {
    public static void main(String[] args) {
        OptionalInt firstGreaterThanFive = IntStream.range(1, 10)
                                                     .filter(n -> n > 5)
                                                     .findFirst(); // Прерываем при нахождении первого элемента

        firstGreaterThanFive.ifPresent(System.out::println); // Вывод: 6
    }
}
```

### 3. Использование `anyMatch()`, `allMatch()` или `noneMatch()`

Эти методы позволяют проверить, соответствует ли хотя бы один элемент, все элементы или ни один элемент заданному условию, и останавливают обработку, как только условие выполнено.

```java
import java.util.stream.IntStream;

public class MatchExample {
    public static void main(String[] args) {
        boolean hasEven = IntStream.range(1, 10)
                                    .anyMatch(n -> n % 2 == 0); // Прерываем при нахождении первого четного числа

        System.out.println(hasEven); // Вывод: true
    }
}
```

### 4. Использование `forEachOrdered()`

Если вы используете параллельные потоки и хотите гарантировать порядок обработки, вы можете использовать метод `forEachOrdered()`, но он не предоставляет возможности прервать выполнение. Это просто способ обработки элементов в порядке их появления.

### Заключение

Хотя в Java Stream API нет прямого способа прервать выполнение потока, как это делается с помощью `break`, вы можете использовать различные методы для управления потоком и остановки обработки в зависимости от ваших потребностей. Методы `filter()`, `findFirst()`, `anyMatch()` и другие позволяют контролировать, какие элементы обрабатываются, и эффективно управлять потоком данных.

## 33. Возможно ли пропустить элемент потока по аналогии с continue?
Да, в Java Stream API вы можете пропустить элементы потока, используя метод `filter()`. Этот метод позволяет отфильтровывать элементы, которые не соответствуют заданному условию, аналогично тому, как оператор `continue` в цикле пропускает текущую итерацию и переходит к следующей.

### Пример использования `filter()`

Допустим, у вас есть поток чисел, и вы хотите пропустить все четные числа, оставив только нечетные:

```java
import java.util.stream.IntStream;

public class ContinueExample {
    public static void main(String[] args) {
        IntStream.range(1, 10)
                 .filter(n -> n % 2 != 0) // Пропускаем четные числа
                 .forEach(System.out::println); // Вывод: 1, 3, 5, 7, 9
    }
}
```

### Как это работает

1. **Создание потока**: В данном примере создается поток целых чисел от 1 до 9.
2. **Фильтрация**: Метод `filter(n -> n % 2 != 0)` пропускает все четные числа, оставляя только нечетные.
3. **Вывод**: Метод `forEach(System.out::println)` выводит оставшиеся нечетные числа.

### Альтернативный способ: `peek()`

Если вам нужно просто "пропустить" элемент (например, для отладки или логирования) и продолжить обработку, вы можете использовать метод `peek()`. Однако `peek()` не удаляет элементы, а просто позволяет вам выполнить действие с каждым элементом потока.

```java
import java.util.stream.IntStream;

public class PeekExample {
    public static void main(String[] args) {
        IntStream.range(1, 10)
                 .peek(n -> {
                     if (n % 2 == 0) {
                         System.out.println("Пропускаем: " + n);
                     }
                 })
                 .filter(n -> n % 2 != 0) // Пропускаем четные числа
                 .forEach(System.out::println); // Вывод: 1, 3, 5, 7, 9
    }
}
```

### Заключение

В Java Stream API вы можете пропустить элементы потока, используя метод `filter()`, который позволяет отфильтровывать элементы на основе заданного условия. Это аналогично оператору `continue` в циклах. Метод `peek()` также может быть полезен для выполнения действий с элементами потока, не изменяя их, что может быть полезно для отладки или логирования.

## 34. Что такое Optional?
`Optional` — это контейнерный объект в Java, который может содержать или не содержать значение. Он был введен в Java 8 для того, чтобы помочь разработчикам избежать проблем, связанных с `NullPointerException`, и сделать код более безопасным и выразительным.

### Основные особенности `Optional`

1. **Предотвращение `NullPointerException`**: `Optional` помогает избежать явного использования `null`, что снижает вероятность возникновения ошибок, связанных с отсутствующими значениями.

2. **Явное указание на отсутствие значения**: Вместо того чтобы возвращать `null`, методы могут возвращать `Optional`, что делает намерение более ясным.

3. **Методы для работы с значениями**: `Optional` предоставляет множество методов для работы с содержащимся значением, таких как `isPresent()`, `ifPresent()`, `orElse()`, `orElseGet()`, `orElseThrow()`, и другие.

### Пример использования `Optional`

Вот пример, демонстрирующий, как использовать `Optional`:

```java
import java.util.Optional;

public class OptionalExample {
    public static void main(String[] args) {
        // Создание Optional с значением
        Optional<String> optionalValue = Optional.of("Hello, World!");

        // Проверка, есть ли значение
        if (optionalValue.isPresent()) {
            System.out.println(optionalValue.get()); // Вывод: Hello, World!
        }

        // Использование ifPresent для выполнения действия, если значение присутствует
        optionalValue.ifPresent(value -> System.out.println("Сообщение: " + value));

        // Создание Optional, который может быть пустым
        Optional<String> emptyOptional = Optional.empty();

        // Значение по умолчанию, если значение отсутствует
        String defaultValue = emptyOptional.orElse("Значение по умолчанию");
        System.out.println(defaultValue); // Вывод: Значение по умолчанию

        // Использование orElseGet для ленивой инициализации
        String lazyValue = emptyOptional.orElseGet(() -> "Ленивая инициализация");
        System.out.println(lazyValue); // Вывод: Ленивая инициализация

        // Генерация исключения, если значение отсутствует
        try {
            emptyOptional.orElseThrow(() -> new IllegalArgumentException("Значение отсутствует!"));
        } catch (IllegalArgumentException e) {
            System.out.println(e.getMessage()); // Вывод: Значение отсутствует!
        }
    }
}
```

### Основные методы `Optional`

- **`of(T value)`**: Создает `Optional`, содержащий ненулевое значение.
- **`ofNullable(T value)`**: Создает `Optional`, который может содержать значение или быть пустым.
- **`empty()`**: Создает пустой `Optional`.
- **`isPresent()`**: Возвращает `true`, если значение присутствует.
- **`ifPresent(Consumer<? super T> action)`**: Выполняет действие, если значение присутствует.
- **`get()`**: Возвращает значение, если оно присутствует; в противном случае выбрасывает `NoSuchElementException`.
- **`orElse(T other)`**: Возвращает значение, если оно присутствует; в противном случае возвращает `other`.
- **`orElseGet(Supplier<? extends T> other)`**: Возвращает значение, если оно присутствует; в противном случае вызывает `Supplier` и возвращает его результат.
- **`orElseThrow(Supplier<? extends X> exceptionSupplier)`**: Возвращает значение, если оно присутствует; в противном случае выбрасывает исключение, создаваемое `Supplier`.

### Заключение

`Optional` — это мощный инструмент для обработки значений, которые могут отсутствовать. Он делает код более безопасным и понятным, позволяя избежать распространенных проблем с `null`. Использование `Optional` способствует более чистому и выразительному коду, улучшая обработку возможных исключений.

## 35. Перечислите методы Optional.
`Optional` в Java предоставляет множество методов для работы с значениями, которые могут быть отсутствующими. Вот основные методы, доступные в классе `Optional`:

### Основные методы `Optional`

1. **Создание экземпляров:**
   - `static <T> Optional<T> of(T value)`: Создает `Optional`, содержащий ненулевое значение. Если значение `null`, выбрасывает `NullPointerException`.
   - `static <T> Optional<T> ofNullable(T value)`: Создает `Optional`, который может содержать значение или быть пустым. Если значение `null`, возвращает пустой `Optional`.
   - `static <T> Optional<T> empty()`: Создает пустой `Optional`.

2. **Проверка наличия значения:**
   - `boolean isPresent()`: Возвращает `true`, если значение присутствует, иначе `false`.
   - `boolean isEmpty()`: Возвращает `true`, если значение отсутствует, иначе `false` (доступен с Java 11).

3. **Получение значения:**
   - `T get()`: Возвращает значение, если оно присутствует; в противном случае выбрасывает `NoSuchElementException`.
   - `T orElse(T other)`: Возвращает значение, если оно присутствует; в противном случае возвращает `other`.
   - `T orElseGet(Supplier<? extends T> other)`: Возвращает значение, если оно присутствует; в противном случае вызывает `Supplier` и возвращает его результат.
   - `T orElseThrow(Supplier<? extends X> exceptionSupplier)`: Возвращает значение, если оно присутствует; в противном случае выбрасывает исключение, создаваемое `Supplier`.

4. **Выполнение действия с значением:**
   - `void ifPresent(Consumer<? super T> action)`: Выполняет действие, если значение присутствует.

5. **Преобразование и фильтрация:**
   - `<U> Optional<U> map(Function<? super T, ? extends U> mapper)`: Применяет функцию к значению, если оно присутствует, и возвращает `Optional` с результатом.
   - `<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper)`: Применяет функцию, возвращающую `Optional`, к значению, если оно присутствует, и возвращает результат.
   - `Optional<T> filter(Predicate<? super T> predicate)`: Возвращает `Optional`, содержащий значение, если оно присутствует и соответствует условию; в противном случае возвращает пустой `Optional`.

6. **Сравнение и хеширование:**
   - `boolean equals(Object obj)`: Сравнивает текущий `Optional` с другим объектом.
   - `int hashCode()`: Возвращает хеш-код для `Optional`.
   - `String toString()`: Возвращает строковое представление `Optional`.

### Пример использования методов `Optional`

```java
import java.util.Optional;

public class OptionalMethodsExample {
    public static void main(String[] args) {
        Optional<String> optionalValue = Optional.of("Hello, World!");
        
        // Проверка наличия значения
        if (optionalValue.isPresent()) {
            System.out.println(optionalValue.get()); // Hello, World!
        }

        // Использование orElse
        String value = optionalValue.orElse("Default Value");
        System.out.println(value); // Hello, World!

        // Использование ifPresent
        optionalValue.ifPresent(v -> System.out.println("Value is: " + v));

        // Использование map
        Optional<Integer> length = optionalValue.map(String::length);
        length.ifPresent(l -> System.out.println("Length: " + l)); // Length: 13

        // Использование filter
        Optional<String> filteredValue = optionalValue.filter(v -> v.startsWith("Hello"));
        filteredValue.ifPresent(System.out::println); // Hello, World!

        // Использование orElseThrow
        Optional<String> emptyOptional = Optional.empty();
        try {
            emptyOptional.orElseThrow(() -> new IllegalArgumentException("Value is absent!"));
        } catch (IllegalArgumentException e) {
            System.out.println(e.getMessage()); // Value is absent!
        }
    }
}
```

### Заключение

Методы `Optional` обеспечивают безопасный и удобный способ работы с возможными отсутствующими значениями, минимизируя вероятность возникновения `NullPointerException` и улучшая читаемость кода.


## 36. В чем разница между методами orElse() и orElseGet()?
Методы `orElse()` и `orElseGet()` в классе `Optional` в Java оба используются для предоставления значения по умолчанию в случае, если значение в `Optional` отсутствует. Однако между ними есть ключевые различия в том, как они работают и когда их следует использовать.

### Разница между `orElse()` и `orElseGet()`

1. **Тип аргумента**:
   - **`orElse(T other)`**: Этот метод принимает значение по умолчанию непосредственно в качестве аргумента. Значение будет вычислено и передано сразу, независимо от того, присутствует ли значение в `Optional` или нет.
   - **`orElseGet(Supplier<? extends T> other)`**: Этот метод принимает `Supplier`, который будет вызываться только в том случае, если значение в `Optional` отсутствует. Это позволяет отложить вычисление значения до момента, когда оно действительно потребуется.

2. **Ленивая инициализация**:
   - **`orElse()`**: Значение по умолчанию создается сразу при вызове метода, даже если оно не будет использовано. Это может привести к ненужным вычислениям, если значение в `Optional` присутствует.
   - **`orElseGet()`**: Значение создается только в случае, если `Optional` пустой. Это позволяет избежать ненужных затрат на вычисления, если значение присутствует.

### Пример использования

```java
import java.util.Optional;

public class OrElseVsOrElseGet {
    public static void main(String[] args) {
        Optional<String> optionalWithValue = Optional.of("Hello");
        Optional<String> emptyOptional = Optional.empty();

        // Использование orElse
        String result1 = optionalWithValue.orElse(getDefaultValue());
        System.out.println(result1); // Вывод: Hello

        String result2 = emptyOptional.orElse(getDefaultValue());
        System.out.println(result2); // Вывод: Default Value (вычислится, даже если Optional пуст)

        // Использование orElseGet
        String result3 = optionalWithValue.orElseGet(() -> getDefaultValue());
        System.out.println(result3); // Вывод: Hello

        String result4 = emptyOptional.orElseGet(() -> getDefaultValue());
        System.out.println(result4); // Вывод: Default Value (вычислится только если Optional пуст)

        // Проверка, что getDefaultValue() вызывается только для пустого Optional
        System.out.println("Using orElseGet:");
        String result5 = emptyOptional.orElseGet(() -> {
            System.out.println("getDefaultValue() was called");
            return getDefaultValue();
        });
        System.out.println(result5); // Вывод: getDefaultValue() was called, Default Value
    }

    private static String getDefaultValue() {
        return "Default Value";
    }
}
```

### Выводы

- Используйте **`orElse()`**, когда значение по умолчанию является простым и не требует дополнительных вычислений.
- Используйте **`orElseGet()`**, когда значение по умолчанию требует вычислений или когда вы хотите отложить это вычисление до момента, когда оно действительно понадобится. Это особенно полезно для сложных операций или при наличии затратных вычислений.

## 37. Расскажите про фабричные методы List.of, Set.of, Map.of?
Фабричные методы `List.of()`, `Set.of()` и `Map.of()` были введены в Java 9 и предоставляют удобные и лаконичные способы создания неизменяемых коллекций. Эти методы позволяют создавать коллекции с фиксированным количеством элементов без необходимости использования дополнительных классов, таких как `ArrayList`, `HashSet` или `HashMap`. Рассмотрим каждый из этих методов подробнее.

### 1. `List.of()`

Метод `List.of()` создает неизменяемый список. Он принимает переменное количество аргументов, которые будут добавлены в список.

#### Пример использования:

```java
import java.util.List;

public class ListOfExample {
    public static void main(String[] args) {
        List<String> list = List.of("Apple", "Banana", "Cherry");
        
        System.out.println(list); // Вывод: [Apple, Banana, Cherry]

        // Попытка изменить список вызовет UnsupportedOperationException
        // list.add("Date"); // Это приведет к ошибке
    }
}
```

### 2. `Set.of()`

Метод `Set.of()` создает неизменяемое множество. Он также принимает переменное количество аргументов и автоматически удаляет дубликаты.

#### Пример использования:

```java
import java.util.Set;

public class SetOfExample {
    public static void main(String[] args) {
        Set<String> set = Set.of("Apple", "Banana", "Cherry", "Apple"); // Дубликат "Apple" будет проигнорирован
        
        System.out.println(set); // Вывод: [Apple, Banana, Cherry]

        // Попытка изменить множество вызовет UnsupportedOperationException
        // set.add("Date"); // Это приведет к ошибке
    }
}
```

### 3. `Map.of()`

Метод `Map.of()` создает неизменяемую карту. Он принимает пары ключ-значение в виде переменного числа аргументов. Если ввести дублирующиеся ключи, будет выброшено `IllegalArgumentException`.

#### Пример использования:

```java
import java.util.Map;

public class MapOfExample {
    public static void main(String[] args) {
        Map<String, Integer> map = Map.of("Apple", 1, "Banana", 2, "Cherry", 3);
        
        System.out.println(map); // Вывод: {Apple=1, Banana=2, Cherry=3}

        // Попытка изменить карту вызовет UnsupportedOperationException
        // map.put("Date", 4); // Это приведет к ошибке

        // Пример дублирующего ключа
        // Map.of("Apple", 1, "Banana", 2, "Apple", 3); // Это приведет к IllegalArgumentException
    }
}
```

### Примечания

1. **Неизменяемость**: Коллекции, созданные с помощью `List.of()`, `Set.of()` и `Map.of()`, являются неизменяемыми. Это означает, что после их создания вы не можете добавлять, удалять или изменять элементы.

2. **Производительность**: Эти методы обеспечивают более эффективное создание коллекций, чем использование конструкторов с добавлением элементов, поскольку они оптимизированы для создания неизменяемых коллекций.

3. **Удобство**: Фабричные методы делают код более читаемым и лаконичным, уменьшая количество строк кода, необходимых для создания коллекций.

4. **Параметры**: Для `Map.of()` можно передать до 10 пар ключ-значение. Если нужно создать карту с большим количеством элементов, можно использовать `Map.ofEntries()`.

### Заключение

Фабричные методы `List.of()`, `Set.of()` и `Map.of()` являются мощными инструментами для создания неизменяемых коллекций в Java, которые упрощают код и улучшают его читаемость, обеспечивая при этом высокую производительность.

## 38. Для чего используется var?
В Java `var` используется для объявления локальных переменных с типом, который будет выведен компилятором на основе присвоенного значения. Эта функция была введена в Java 10 и позволяет разработчикам писать более лаконичный и читаемый код, избавляя от необходимости явно указывать тип переменной, когда это не требуется.

### Преимущества использования `var`

1. **Упрощение кода**: `var` позволяет избежать избыточности в коде, особенно когда тип переменной очевиден из контекста.
   
   ```java
   var list = new ArrayList<String>(); // Вместо: ArrayList<String> list = new ArrayList<>();
   ```

2. **Улучшение читаемости**: В некоторых случаях использование `var` может сделать код более чистым и легче воспринимаемым, особенно при работе с длинными типами.

   ```java
   var stream = someList.stream(); // Вместо: Stream<String> stream = someList.stream();
   ```

3. **Упрощение работы с обобщениями**: Когда вы работаете с обобщенными типами, использование `var` может существенно сократить количество кода.

   ```java
   var map = new HashMap<String, List<String>>(); // Вместо: HashMap<String, List<String>> map = new HashMap<>();
   ```

### Ограничения использования `var`

1. **Локальные переменные**: `var` можно использовать только для локальных переменных в методах, конструкторах и инициализаторах. Нельзя использовать `var` для полей класса, параметров методов или возвращаемых значений.

   ```java
   var x = 10; // Правильно
   // var y; // Неправильно: переменная должна быть инициализирована
   ```

2. **Неявный тип**: Тип переменной определяется компилятором на этапе компиляции. Это означает, что вы не можете использовать `var`, если тип не может быть однозначно выведен.

   ```java
   var value; // Неправильно: переменная должна быть инициализирована
   ```

3. **Потеря явности**: Использование `var` может привести к потере явности кода, если тип переменной не очевиден из контекста. Это может затруднить чтение кода для других разработчиков.

   ```java
   var result = someMethod(); // Непонятно, какой тип возвращает someMethod()
   ```

### Примеры использования `var`

#### Пример 1: Простой пример

```java
var number = 10; // int
var name = "Java"; // String
```

#### Пример 2: Сложные типы

```java
var list = List.of(1, 2, 3); // List<Integer>
var map = Map.of("key", "value"); // Map<String, String>
```

#### Пример 3: Использование с потоками

```java
var stream = list.stream(); // Stream<Integer>
```

### Заключение

Использование `var` в Java позволяет сделать код более лаконичным и читаемым, но требует осторожности, чтобы не потерять явность типов. Это удобный инструмент, который может улучшить качество кода, если использовать его в подходящих контекстах.

## 39. В каких случаях можно использовать var?
`var` в Java можно использовать в следующих случаях:

### 1. Локальные переменные

`var` предназначен для объявления локальных переменных, которые инициализируются при объявлении. Например:

```java
var number = 10; // int
var name = "Java"; // String
```

### 2. Коллекции и обобщенные типы

`var` особенно полезен при работе с обобщениями и коллекциями, где тип может быть длинным и сложным:

```java
var list = new ArrayList<String>(); // ArrayList<String>
var map = new HashMap<String, List<String>>(); // HashMap<String, List<String>
```

### 3. Использование с потоками

При работе с потоками или другими API, где тип возвращаемого значения может быть сложным, `var` позволяет упростить код:

```java
var stream = list.stream(); // Stream<String>
```

### 4. Лямбда-выражения и функциональные интерфейсы

`var` можно использовать в контексте лямбда-выражений:

```java
var consumer = (var s) -> System.out.println(s); // Consumer<String>
```

### 5. В комбинации с методами, возвращающими обобщенные типы

Если метод возвращает обобщенный тип, вы можете использовать `var` для упрощения объявления переменной:

```java
var result = someGenericMethod(); // Тип будет выведен компилятором
```

### Ограничения использования `var`

1. **Не может быть использован для полей класса**: `var` нельзя использовать для объявления полей класса или параметров методов.

   ```java
   // Неправильно
   // var field = 5; // Ошибка
   ```

2. **Не может быть использован без инициализации**: Переменная, объявленная с помощью `var`, должна быть инициализирована сразу же.

   ```java
   // Неправильно
   // var x; // Ошибка: переменная должна быть инициализирована
   ```

3. **Неявный тип**: Компилятор должен иметь возможность вывести тип переменной из контекста. Если это невозможно, использование `var` вызовет ошибку.

   ```java
   // Неправильно
   // var value; // Ошибка: тип не может быть выведен
   ```

### Примеры использования `var`

#### Пример 1: Простой пример

```java
var count = 42; // int
var greeting = "Hello, World!"; // String
```

#### Пример 2: Коллекции

```java
var list = List.of("Apple", "Banana", "Cherry"); // List<String>
var set = Set.of(1, 2, 3); // Set<Integer>
```

#### Пример 3: Работа с API

```java
var optionalValue = Optional.of("Hello"); // Optional<String>
```

### Заключение

`var` является мощным инструментом в Java, который позволяет упростить код и улучшить его читаемость. Однако его следует использовать с осторожностью, чтобы не потерять явность типов и не усложнить понимание кода для других разработчиков.
